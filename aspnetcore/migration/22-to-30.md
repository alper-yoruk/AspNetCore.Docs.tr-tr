---
title: ASP.NET Core 2,2 ' den 3,0 ' e geçiş yapın
author: rick-anderson
description: ASP.NET Core 2,2 projesini ASP.NET Core 3,0 ' e geçirmeyi öğrenin.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 5f6b0b8d56649dc5fd194ee43d93139f80ce9106
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060436"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2,2 ' den 3,0 ' e geçiş yapın

[Scott Ade](https://github.com/scottaddie) ve [Rick Anderson](https://twitter.com/RickAndMSFT) tarafından

Bu makalede, mevcut bir ASP.NET Core 2,2 projesinin ASP.NET Core 3,0 ' e nasıl güncelleştirilmesi açıklanmaktadır. Yeni bir ASP.NET Core 3,0 projesi oluşturmak yararlı olabilir:

* ASP.NET Core 2,2 kodla karşılaştırın.
* İlgili değişiklikleri ASP.NET Core 3,0 projenize kopyalayın.

## <a name="prerequisites"></a>Önkoşullar

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Mac için Visual Studio](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>global.jsüzerinde .NET Core SDK sürümü Güncelleştir

Çözümünüz belirli bir .NET Core SDK sürümünü hedeflemek için dosyadaki bir [global.js](/dotnet/core/tools/global-json) kullanıyorsa, `version` özelliğini makinenizde yüklü 3,0 sürümü olarak güncelleştirin:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Proje dosyasını güncelleştirme

### <a name="update-the-target-framework"></a>Hedef çerçeveyi güncelleştirme

ASP.NET Core 3,0 ve üzeri yalnızca .NET Core üzerinde çalışır. [Hedef Framework bilinen adını (tfd)](/dotnet/standard/frameworks) şu şekilde ayarlayın `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Kullanımdan kaldırılmış paket başvurularını kaldır

ASP.NET Core 3,0 için çok sayıda NuGet paketi üretilmez. Bu tür paket başvuruları proje dosyasından kaldırılmalıdır. ASP.NET Core 2,2 Web uygulaması için aşağıdaki proje dosyasını göz önünde bulundurun:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

ASP.NET Core 3,0 için güncelleştirilmiş proje dosyası:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Güncelleştirilmiş ASP.NET Core 3,0 proje dosyası:

* İçinde `<PropertyGroup>` :
  * TFD 'yi güncelleştirme `netcoreapp3.0`
  * Öğeyi kaldırır `<AspNetCoreHostingModel>` . Daha fazla bilgi için bu belgede [Işlem içi barındırma modeli](#in-process-hosting-model) konusuna bakın.

* İçinde `<ItemGroup>` :
  * `Microsoft.AspNetCore.App` kaldırılır. Daha fazla bilgi için bu belgede [Framework başvurusu](#framework-reference) bölümüne bakın.
  * `Microsoft.AspNetCore.Razor.Design` kaldırılır ve aşağıdaki paket listesinde artık üretilmez.

Artık üretilmeyen paketlerin tam listesini görmek için aşağıdaki Genişlet listesini seçin:

<details>
    <summary>Artık üretilmeyen paketlerin listesini genişletmek için tıklayın</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. AspNetCore. Authentication. Cookie malar</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. AspNetCore. Cookie İlkesinin</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. Mvc.Razor</li>
        <li>Microsoft. AspNetCore. Mvc. Razor . ViewCompilation</li>
        <li>Microsoft. AspNetCore. Mvc. Razor Sayfaları</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Çalışma zamanı</li>
        <li>Microsoft. AspNetCore. Razor . Tasarıma</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Çekirdeğin</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Son değişiklikleri gözden geçir

[Son değişiklikleri gözden geçir](#break)

### <a name="framework-reference"></a>Framework başvurusu

Yukarıda listelenen paketlerden biri ile kullanılabilen ASP.NET Core Özellikleri, paylaşılan Framework 'ün bir parçası olarak kullanılabilir `Microsoft.AspNetCore.App` . *Paylaşılan çerçeve* , makinede yüklü olan derlemeler ( *. dll* dosyaları) kümesidir ve bir çalışma zamanı bileşeni ve hedefleme paketi içerir. Daha fazla bilgi için bkz. [paylaşılan çerçeve](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* SDK 'yı hedefleyen projeler `Microsoft.NET.Sdk.Web` çerçeveye dolaylı olarak başvurur `Microsoft.AspNetCore.App` .

  Bu projeler için ek başvuru gerekli değildir:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Hedef `Microsoft.NET.Sdk` veya SDK olan projeler `Microsoft.NET.Sdk.Razor` , öğesine bir açık eklemesi `FrameworkReference` gerekir `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Docker kullanan çerçeveye bağımlı yapılar

ASP.NET Core [paylaşılan çerçeveye](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) bağlı bir paket kullanan konsol uygulamalarının çerçeveye bağımlı derlemeleri aşağıdaki çalışma zamanı hatasına verebilir:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` , ASP.NET Core çalışma zamanını içeren ve yalnızca [DotNet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker görüntüsünde bulunan paylaşılan çerçevedir. 3,0 SDK, paylaşılan çerçevede kullanılabilir olan kitaplıkların yinelenen kopyalarını dahil etmez ASP.NET Core kullanan çerçeveye bağımlı derlemelerin boyutunu azaltır. Bu, 18 MB 'a kadar olası bir tasarruf sağlar, ancak uygulamayı çalıştırmak için ASP.NET Core çalışma zamanının mevcut/yüklü olmasını gerektirir.

ASP.NET Core paylaşılan çerçevede uygulamanın bir bağımlılığı (doğrudan veya dolaylı) olup olmadığını anlamak için, uygulamanızın derlenmesi/yayımlanması sırasında oluşturulan dosyanın *runtimeconfig.js* inceleyin. Aşağıdaki JSON dosyası ASP.NET Core paylaşılan çerçeveye bir bağımlılık gösterir:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Uygulamanız Docker kullanıyorsa, ASP.NET Core 3,0 içeren bir temel görüntü kullanın. Örneğin, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Kaldırılan derlemeler için paket başvuruları Ekle

ASP.NET Core 3,0, daha önce paket başvurusunun parçası olan bazı derlemeleri kaldırır `Microsoft.AspNetCore.App` . Hangi derlemelerin kaldırıldığını görselleştirmek için, iki paylaşılan çerçeve klasörünü karşılaştırın. Örneğin, 2.2.7 ve 3.0.0 sürümlerinin karşılaştırması:

![Paylaşılan çerçeve derlemeleri karşılaştırması](22-to-30/_static/assembly-diff.png)

Kaldırılan derlemeler tarafından sunulan özellikleri kullanmaya devam etmek için, karşılık gelen paketlerin 3,0 sürümlerine başvurun:

* **Bireysel kullanıcı hesaplarıyla** şablon tarafından oluşturulan bir Web uygulaması aşağıdaki paketleri eklemeyi gerektirir:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Veritabanı sağlayıcısına özgü pakete başvurma hakkında daha fazla bilgi için bkz. [veritabanı sağlayıcıları](/ef/core/providers/index).

* Identity 'SıNı

  Microsoft. AspNetCore 'a başvurarak, [ Identity Kullanıcı arabirimi](xref:security/authentication/identity) için destek eklenebilir [. Identity Kullanıcı arabirimi](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) paketi.

* SPA Hizmetleri

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Kimlik doğrulaması: üçüncü taraf kimlik doğrulama akışları için destek, NuGet paketleri olarak kullanılabilir:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft hesabı kimlik doğrulaması ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect kimlik doğrulaması ([Microsoft. AspNetCore. Authentication. Openıdconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect taşıyıcı belirteci ([Microsoft. AspNetCore. Authentication. Jwttaşıyıcı](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation kimlik doğrulaması ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Biçimlendirme ve içerik anlaşması desteği `System.Net.HttpClient` : [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet paketi, `System.Net.HttpClient` ve gibi API 'lerle yararlı genişletilebilirlik sağlar `ReadAsAsync` `PostJsonAsync` .

* Razor çalışma zamanı derlemesi: görünümler ve sayfaların çalışma zamanı derlemesi için destek Razor artık [Microsoft. aspnetcore. Mvc 'nin bir parçasıdır. Razor RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` (JSON.net) desteği: Ile MVC kullanma desteği `Newtonsoft.Json` artık bir parçasıdır [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Başlangıç değişiklikleri

Aşağıdaki görüntüde ASP.NET Core 2,2 pages Web uygulamasında silinen ve değiştirilen çizgiler gösterilmektedir Razor :

![ASP.NET Core 2,2::: No-Loc (Razor)::: Web uygulamasında silinen ve değiştirilen satırlar](22-to-30/_static/startup2.2.png)

Önceki görüntüde, silinen kod kırmızı renkte gösterilir. Silinen kod, cookie dosyalar karşılaştırılmadan önce silinmiş olan seçenek kodunu göstermiyor.

Aşağıdaki görüntüde ASP.NET Core 3,0 pages Web uygulamasında eklenen ve değiştirilen satırlar gösterilmektedir Razor :

![ASP.NET Core 3,0::: No-Loc (Razor)::: Web uygulamasında eklenen ve değiştirilen satırlar](22-to-30/_static/startup3.0.png)

Önceki görüntüde eklenen kod yeşil renkte gösterilir. Aşağıdaki değişiklikler hakkında bilgi için:

* `services.AddMvc` için `services.AddRazorPages` , bkz. bu belgede [MVC hizmeti kaydı](#mvc-service-registration) .
* `CompatibilityVersion`, bkz <xref:mvc/compatibility-version> ..
* `IHostingEnvironment` için `IWebHostEnvironment` [Bu GitHub duyurusunu](https://github.com/dotnet/AspNetCore/issues/7749)inceleyin.
* `app.UseAuthorization` , sipariş yetkilendirme ara yazılımı 'nın eklenmesi gerektiğini göstermek için şablonlara eklenmiştir. Uygulama yetkilendirme kullanmıyorsa, çağrısını güvenle kaldırabilirsiniz `app.UseAuthorization` .
* `app.UseEndpoints`, bu belgede [ Razor sayfalara](#razor-pages) bakın veya [Startup.Configure](#migrate-startupconfigure) ' ı geçirin.

### <a name="analyzer-support"></a>Çözümleyici desteği

`Microsoft.NET.Sdk.Web`Daha önce [Microsoft. aspnetcore. Mvc. çözümleyiciler](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) paketinin bir parçası olarak sevk edilen örtük başvuru Çözümleyicileri hedefleyen projeler. Bunları etkinleştirmek için ek başvuru gerekmez.

Uygulamanız daha önce [Microsoft. AspNetCore. Mvc. API. çözümleyiciler](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) paketini kullanarak sevk edilen [API Çözümleyicileri](xref:web-api/advanced/analyzers) kullanıyorsa, .NET Core Web SDK 'sının bir parçası olarak gönderilen çözümleyiciler için proje dosyanızı düzenleyin:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="no-locrazor-class-library"></a>Razor Sınıf kitaplığı

Razor MVC için UI bileşenleri sağlayan sınıf kitaplığı projelerinin `AddRazorSupportForMvc` Proje dosyasındaki özelliği ayarlaması gerekir:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>İşlem içi barındırma modeli

Projeler varsayılan olarak ASP.NET Core 3,0 veya sonraki sürümlerde [işlem içi barındırma modeline](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) göre yapılır. İsteğe bağlı olarak, `<AspNetCoreHostingModel>` değeri proje dosyasındaki özelliği olarak kaldırabilirsiniz `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Yapılandırma

Kestrel yapılandırmasını (Program.cs) tarafından sunulan [Web ana bilgisayar oluşturucusuna](#hostb) geçirin `ConfigureWebHostDefaults` : *Program.cs*

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Uygulama Konağı ile el ile oluşturursa `HostBuilder` , `UseKestrel` içindeki Web ana bilgisayar Oluşturucu üzerinde çağırın `ConfigureWebHostDefaults` :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Bağlantı ara yazılımı bağlantı bağdaştırıcılarını değiştirir

Bağlantı bağdaştırıcıları ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) Kestrel 'ten kaldırılmıştır. Bağlantı bağdaştırıcılarını bağlantı ara yazılımı ile değiştirin. Bağlantı ara yazılımı, ASP.NET Core işlem hattındaki HTTP ara hattına benzerdir, ancak alt düzey bağlantılar için. HTTPS ve bağlantı günlüğü:

* Bağlantı bağdaştırıcılarından bağlantı ara yazılıma taşınmıştır.
* Bu uzantı yöntemleri ASP.NET Core önceki sürümlerinde olduğu gibi çalışır. 

Daha fazla bilgi için [Kestrel makalesinin ListenOptions. Protocols bölümünde TlsFilterConnectionHandler örneğine](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#listenoptionsprotocols)bakın.

### <a name="transport-abstractions-moved-and-made-public"></a>Taşıma soyutlamaları taşınır ve herkese açık hale getirilir

Kestrel aktarım katmanı, içinde ortak bir arabirim olarak kullanıma sunuldu `Connections.Abstractions` . Bu güncelleştirmelerin bir parçası olarak:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` ve ilişkili türler kaldırılmıştır.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay><xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>, taşıma seçeneklerine taşındı.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` öğesinden kaldırıldı <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Daha fazla bilgi için aşağıdaki GitHub kaynaklarına bakın:

* [İstemci/sunucu ağı soyutlamaları (DotNet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Yeni yatak odası dinleyicisi soyutlama ve yeniden Plat Kestrel for top (DotNet/AspNetCore #10321) uygulayın](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel Istek artbilgisi üst bilgileri

ASP.NET Core önceki sürümlerini hedefleyen uygulamalar için:

* Kestrel istek üstbilgileri koleksiyonuna HTTP/1.1 öbekli treyler üstbilgileri ekler.
* İstek gövdesi uca okunduktan sonra Treyi kullanılabilir.

Bu, üst bilgiler ve tanıtımları arasındaki belirsizlik hakkında bazı kaygılara neden olur. bu nedenle, tanıtımları 3,0 içinde yeni bir koleksiyona ( `RequestTrailerExtensions` ) taşınmıştır.

HTTP/2 istek fragmanları:

* ASP.NET Core 2,2 ' de kullanılamaz.
* 3,0 ile kullanılabilir `RequestTrailerExtensions` .

Bu treylara erişmek için yeni istek uzantısı yöntemleri vardır. HTTP/1.1 ile olduğu gibi, istek gövdesi sonuna kadar okunduktan sonra treylerle erişilebilir.

3,0 sürümü için aşağıdaki `RequestTrailerExtensions` Yöntemler kullanılabilir:

* `GetDeclaredTrailers`: `Trailer` Gövdeden sonra bekleneceğini listeleyen istek üst bilgisini alır.
* `SupportsTrailers`: İsteğin treyler üst bilgilerini almayı destekleyip desteklemediğini gösterir.
* `CheckTrailersAvailable`: İsteğin treyleri destekleyip desteklemediğini ve okunmaları için kullanılabilir olup olmadığını denetler. Bu denetim, okunması gereken tanıtımın olduğunu varsaymaz. Bu yöntem tarafından döndürülse bile okunması gereken bir Treyi olmayabilir `true` .
* `GetTrailer`: Yanıtın sonunda istenen üst bilgiyi alır. `SupportsTrailers`Çağrılmadan önce işaretleyin `GetTrailer` veya <xref:System.NotSupportedException> istek sondaki üstbilgileri desteklemiyorsa meydana gelebilir.

Daha fazla bilgi için bkz. [istek fragmanları ayrı bir koleksiyonda (DotNet/AspNetCore #10410) yerleştirme](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO devre dışı

`AllowSynchronousIO` , ve gibi zaman uyumlu g/ç API 'Lerini etkinleştirilir veya devre dışı bırakır `HttpRequest.Body.Read` `HttpResponse.Body.Write` `Stream.Flush` . Bu API 'Ler, uygulama kilitlenmelerine neden olan bir iş parçacığı kaynağıdır. 3,0 ' de `AllowSynchronousIO` Varsayılan olarak devre dışıdır. Daha fazla bilgi için [Kestrel makalesindeki zaman uyumlu g/ç bölümüne](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#synchronous-io)bakın.

Zaman uyumlu g/ç gerekliyse, `AllowSynchronousIO` kullanılmakta olan sunucu üzerindeki seçeneği yapılandırılarak etkinleştirilebilir ( `ConfigureKestrel` Örneğin, Kestrel kullanılıyorsa). Sunucularının (Kestrel, HttpSys, TestServer, vb.) `AllowSynchronousIO` diğer sunucuları etkilemeyecek kendi seçeneğine sahip olduğunu unutmayın. Zaman uyumlu g/ç, seçeneği kullanılarak istek temelinde tüm sunucular için etkinleştirilebilir `IHttpBodyControlFeature.AllowSynchronousIO` :

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

<xref:System.IO.TextWriter> [Dispose](/dotnet/standard/garbage-collection/implementing-dispose)Içinde zaman uyumlu API 'ler çağıran uygulamalarla veya diğer akışlarla ilgili sorun yaşıyorsanız, <xref:System.IO.Stream.DisposeAsync*> bunun yerine yeni API 'yi çağırın.

Daha fazla bilgi için, bkz. [[Duyuru] Allowsynchronousıo tüm sunucularda devre dışı (DotNet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Çıkış biçimlendirici arabelleğe alma

[Newtonsoft.Js](https://www.newtonsoft.com/json), <xref:System.Xml.Serialization.XmlSerializer> ve <xref:System.Runtime.Serialization.DataContractSerializer> tabanlı çıkış biçimleri yalnızca zaman uyumlu Serileştirmeyi destekler. Bu formatlamalarının, sunucunun [Allowsynchronousıo](https://github.com/dotnet/aspnetcore/issues/7644) kısıtlamalarıyla çalışmasına izin vermek IÇIN, MVC diske yazmadan önce bu formatlamalardan oluşan Çıktıyı arabelleğe alır. Arabelleğe alma işleminin sonucu olarak, MVC bu biçimleri kullanarak yanıt vermediğinde Content-Length üst bilgisini içerecektir.

<xref:System.Text.Json> zaman uyumsuz serileştirme destekler ve sonuç olarak `System.Text.Json` tabanlı biçimlendirici arabelleğe almaz. Daha iyi performans için bu biçimlendirici kullanmayı göz önünde bulundurun.

Arabelleğe almayı devre dışı bırakmak için uygulamalar <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> Başlangıçta yapılandırabilir:

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Bu, aynı zamanda yapılandırılmamışsa uygulamanın bir çalışma zamanı özel durumu oluşturmasıyla sonuçlanabileceğini unutmayın `AllowSynchronousIO` .

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft. AspNetCore. Server. Kestrel. https derlemesi kaldırıldı

ASP.NET Core 2,1 ' de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* içerikleri *Microsoft.AspNetCore.Server.Kestrel.Core.dll* ' e taşınmıştır. Bu, öznitelikleri kullanan bir kırılmamış güncelleştirmedir `TypeForwardedTo` . 3,0 için, boş *Microsoft.AspNetCore.Server.Kestrel.Https.dll* derlemesi ve NuGet paketi kaldırılmıştır.

[Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) ' ye başvuran kitaplıklar ASP.NET Core bağımlılıklarını 2,1 veya üzeri bir sürüme güncelleştirmemelidir.

ASP.NET Core 2,1 veya sonraki bir sürümü hedefleyen uygulamalar ve kitaplıklar, [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) paketine doğrudan başvuruları kaldırmalıdır.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Newtonsoft.Json (Json.NET) desteği

[ASP.NET Core paylaşılan Framework 'ün geliştirilmesi](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)için işin bir parçası olarak, ASP.NET Core paylaşılan çerçevesinden [Newtonsoft.Jsüzerinde (JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) kaldırılmıştır.

ASP.NET Core için varsayılan JSON serileştirici artık <xref:System.Text.Json> .NET Core 3,0 ' de yenidir. Mümkün olduğunda kullanmayı göz önünde bulundurun `System.Text.Json` . Bu yüksek performanstır ve ek bir kitaplık bağımlılığı gerektirmez. Ancak, `System.Text.Json` yeni olduğundan uygulamanızın ihtiyaç duyacağı Özellikler Şu anda eksik olabilir. Daha fazla bilgi için bkz. [Newtonsoft.Jsüzerinde System.Text.Jsüzerine geçiş](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-no-locsignalr-project"></a>ASP.NET Core 3,0 projesinde Newtonsoft.Jskullanma SignalR

* [Microsoft. AspNetCore ' u yükler. SignalR Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet paketi.

* İstemcisinde, `AddNewtonsoftJsonProtocol` örneğine bir yöntem çağrısı zincirleyebilirsiniz `HubConnectionBuilder` :

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Sunucusunda, `AddNewtonsoftJsonProtocol` içinde yöntem çağrısına bir yöntem çağrısı zincirleyebilirsiniz `AddSignalR` `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>ASP.NET Core 3,0 MVC projesinde Newtonsoft.Jskullanma

* Paketi yükler [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* `Startup.ConfigureServices`Çağrılacak güncelleştirme `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` , yeni MVC hizmeti kayıt yöntemleriyle uyumludur:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` için yapılan çağrıda ayarlar ayarlanabilir `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

  **Note:** `AddNewtonsoftJson` Yöntem kullanılamıyorsa, paketini yüklediğinizden emin olun [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) . Yaygın bir hata, paket yerine [Newtonsoft.Js](https://www.nuget.org/packages/Newtonsoft.Json/) pakete yüklemektir [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

Daha fazla bilgi için bkz. [Newtonsoft.Jstabanlı JSON biçimi desteği ekleme](xref:web-api/advanced/formatting#add-newtonsoftjson-based-json-format-support).

## <a name="mvc-service-registration"></a>MVC hizmeti kaydı

ASP.NET Core 3,0, içinde MVC senaryolarını kaydetmek için yeni seçenekler ekler `Startup.ConfigureServices` .

Üzerinde MVC senaryolarıyla ilgili üç yeni en üst düzey uzantı yöntemi `IServiceCollection` kullanılabilir. Şablonlar yerine bu yeni yöntemleri kullanır `AddMvc` . Ancak, `AddMvc` önceki sürümlerde olduğu gibi davranmaya devam eder.

Aşağıdaki örnek, denetleyiciler ve API ile ilgili özellikler için destek ekler, ancak görünümler veya sayfalar değildir. API şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Aşağıdaki örnek, denetleyiciler, API ile ilgili özellikler ve görünümler için destek ekler, ancak sayfalar için değildir. Web uygulaması (MVC) şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Aşağıdaki örnek, Razor Sayfalar ve en düşük denetleyici desteği için destek ekler. Web uygulaması şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Yeni yöntemler de birleştirilebilir. Aşağıdaki örnek, `AddMvc` ASP.NET Core 2,2 ' de çağırma ile eşdeğerdir:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Yönlendirme başlangıç kodu

Bir uygulama `UseMvc` veya olarak çağırırsa `UseSignalR` , mümkünse uygulamayı [Endpoint Routing](xref:fundamentals/routing) 'e geçirin. MVC 'nin önceki sürümleriyle Endpoint Routing uyumluluğu geliştirmek için ASP.NET Core 2,2 ' de sunulan URL oluşturmayla ilgili bazı değişiklikleri geri çevirdik. 2,2 ' de Endpoint Routing kullanarak sorunlarla karşılaşırsanız, aşağıdaki özel durumlarla ASP.NET Core 3,0 ' de iyileştirmeler beklenir:

* Uygulama, öğesinden uyguluyorsa `IRouter` veya devralırsa `Route` , değiştirme olarak [Dynamikro Utevaluestranseski](https://github.com/dotnet/AspNetCore.Docs/issues/12997) kullanın.
* Uygulama, `RouteData.Routers` URL 'leri ayrıştırmaya doğrudan MVC 'nin içine erişirse, bunu [Linkparser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)kullanımı ile değiştirebilirsiniz. 
  * Yolu bir rota adı ile tanımlayın.
  * `LinkParser.ParsePathByEndpointName`İstediğiniz yol adını kullanın ve geçirin.

Uç nokta yönlendirme, aynı yol deseninin sözdizimini ve yönlendirme deseninin yazma özelliklerini destekler `IRouter` . Uç nokta yönlendirme destekler `IRouteConstraint` . Endpoint Routing `[Route]` ,, `[HttpGet]` ve diğer mvc yönlendirme özniteliklerini destekler.

Çoğu uygulama için yalnızca `Startup` değişiklik yapılması gerekir.

### <a name="migrate-startupconfigure"></a>Startup.Configure geçir

Genel öneri:

* Ekleyin `UseRouting` .
* Uygulama çağrııyorsa `UseStaticFiles` , daha `UseStaticFiles` **önce** yerleştirin `UseRouting` .
* Uygulama, veya gibi kimlik doğrulama/yetkilendirme özelliklerini kullanıyorsa `AuthorizePage` `[Authorize]` , bu çağrıyı `UseAuthentication` ve `UseAuthorization` önüne: **sonra** , `UseRouting` `UseCors` , ancak önce `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* `UseMvc`Veya `UseSignalR` ile değiştirin `UseEndpoints` .
* Uygulama gibi [CORS](xref:security/cors) senaryoları KULLANıYORSA `[EnableCors]` , `UseCors` CORS 'yi kullanan diğer herhangi bir ara yazılım (örneğin,, ve ' dan önce yer alan) için çağrısı yapın `UseCors` `UseAuthentication` `UseAuthorization` `UseEndpoints` .
* `IHostingEnvironment`İle değiştirin `IWebHostEnvironment` ve `using` ad alanı için bir ifade ekleyin <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> .
* Öğesini `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ad alanı) ile değiştirin.
* Öğesini `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ad alanı) ile değiştirin.

Aşağıdaki kod, `Startup.Configure` tipik bir ASP.NET Core 2,2 uygulamasında bir örneğidir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Önceki kodu güncelleştirdikten sonra `Startup.Configure` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Çoğu uygulama için,, `UseAuthentication` ve çağrıları `UseAuthorization` `UseCors` `UseRouting` etkili olması için ve çağrıları arasında görünmelidir `UseEndpoints` .

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, genel ana bilgisayar ile Endpoint Routing kullanır. ' De, uç nokta `Startup.Configure` `MapHealthChecks` URL 'si veya göreli yol ile Endpoint Builder ' ı çağırın:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Durum denetimleri uç noktaları şunları yapabilir:

* İzin verilen bir veya daha fazla Konakları/bağlantı noktasını belirtin.
* Yetkilendirme gerektir.
* CORS gerektir.

Daha fazla bilgi için bkz. <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Güvenlik ara yazılımı Kılavuzu

Yetkilendirme ve CORS desteği, [Ara yazılım](xref:fundamentals/middleware/index) yaklaşımına göre birleştirilmiştir. Bu, bu senaryolarda aynı ara yazılım ve işlevselliğin kullanılmasına izin verir. Bu sürümde güncelleştirilmiş bir yetkilendirme ara yazılımı sunulmaktadır ve CORS ara yazılımı, MVC denetleyicileri tarafından kullanılan öznitelikleri anlayabilmesi için geliştirilmiştir.

#### <a name="cors"></a>CORS

Daha önce CORS yapılandırması zor olabilir. Ara yazılım bazı kullanım durumlarında kullanılmak üzere sağlandı, ancak MVC filtrelerinin diğer kullanım durumlarında ara yazılım **olmadan** kullanılması amaçlandı. ASP.NET Core 3,0 ile, CORS gerektiren tüm uygulamaların, uç nokta yönlendirme ile birlikte CORS ara yazılımını kullanması önerilir. `UseCors` , varsayılan bir ilkeyle ve `[EnableCors]` `[DisableCors]` gerekli olduğunda varsayılan ilkeyi geçersiz kılmak için öznitelikler kullanılabilir.

Aşağıdaki örnekte:

* CORS, adlandırılmış ilkeye sahip tüm uç noktalar için etkinleştirilmiştir `default` .
* `MyController`Sınıfı, CORS 'yi özniteliğiyle devre dışı bırakır `[DisableCors]` .

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Yetkilendirme

ASP.NET Core önceki sürümlerinde, yetkilendirme desteği özniteliği aracılığıyla sağlandı `[Authorize]` . Yetkilendirme ara yazılımı kullanılamıyor. ASP.NET Core 3,0 ' de, yetkilendirme ara yazılımı gereklidir. ASP.NET Core yetkilendirmesi ara yazılımını ( `UseAuthorization` ) hemen sonra yerleştirmenizi öneririz `UseAuthentication` . Yetkilendirme ara yazılımı, geçersiz kılınabilen varsayılan ilkeyle de yapılandırılabilir.

ASP.NET Core 3,0 veya üzeri sürümlerde ' de `UseAuthorization` çağrılır `Startup.Configure` ve aşağıdakiler `HomeController` oturum açmış bir kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Endpoint Routing kullanırken, `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` Yetkilendirme ara yazılımını yapılandırmak ve bunun yerine güvenmek önerilir.  Uygulama, `AuthorizeFilter` MVC 'de genel bir filtre olarak kullanıyorsa, çağrısına bir ilke sağlamak için kodu yeniden düzenlemeyi öneririz `AddAuthorization` .

`DefaultPolicy`Başlangıçta kimlik doğrulaması gerektirecek şekilde yapılandırıldığında, ek yapılandırma gerekmez. Aşağıdaki örnekte, MVC uç noktaları `RequireAuthorization` , tüm isteklerin öğesine göre yetkilendirilmiş olması için olarak işaretlenir `DefaultPolicy` . Bununla birlikte, `HomeController` Kullanıcı uygulamada oturum açmadan erişime izin verir, çünkü `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Belirli uç noktalar için yetkilendirme

Yetkilendirme, belirli uç nokta sınıfları için de yapılandırılabilir. Aşağıdaki kod, `AuthorizeFilter` yetkilendirme gerektiren belirli bir ilkeye sahip bir uygulamaya küresel olarak yapılandırılmış BIR MVC uygulamasını dönüştürme örneğidir:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

İlkeler de özelleştirilebilir. , `DefaultPolicy` Kimlik doğrulaması gerektirecek şekilde yapılandırılır:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternatif olarak, tüm uç noktalar `[Authorize]` bir veya yapılandırması olmadan yetkilendirme gerektirecek şekilde yapılandırılabilir `RequireAuthorization` `FallbackPolicy` . , `FallbackPolicy` Öğesinden farklıdır `DefaultPolicy` . , `DefaultPolicy` Veya tarafından tetiklenir `[Authorize]` `RequireAuthorization` , ancak başka bir `FallbackPolicy` ilke ayarlanmamışsa tetiklenir. `FallbackPolicy` Başlangıçta yetkilendirmesiz isteklere izin verecek şekilde yapılandırılmıştır.

Aşağıdaki örnek, önceki örnekle aynıdır, `DefaultPolicy` ancak `FallbackPolicy` belirtilen durumlar hariç tüm uç noktalarında her zaman kimlik doğrulaması gerektirmek için kullanır `[AllowAnonymous]` :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Belirli bir yetkilendirme bilgisine sahip olmayan, ara yazılım tarafından yetkilendirme çalışmaktadır. Örneğin, [sistem durumu denetimlerinde](xref:host-and-deploy/health-checks) belirli bir yetkilendirme bilgisi yoktur, ancak sistem durumu denetimleri, ara yazılım tarafından uygulanan yapılandırılabilir bir yetkilendirme ilkesine sahip olabilir.

Ayrıca, her uç nokta yetkilendirme gereksinimlerini özelleştirebilir. Aşağıdaki örnekte, `UseAuthorization` ile yetkilendirmeyi işler `DefaultPolicy` , ancak `/healthz` sistem durumu denetimi uç noktası bir `admin` Kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Koruma bazı senaryolar için uygulanır. Bir yetkilendirme veya CORS ilkesi eksik ara yazılım nedeniyle atlandıysa uç noktalar ara yazılımı bir özel durum oluşturur. Yanlış yapılandırma hakkında ek geribildirim sağlamak için çözümleyici desteği devam ediyor.

#### <a name="custom-authorization-handlers"></a>Özel yetkilendirme işleyicileri

Uygulama özel [Yetkilendirme işleyicileri](xref:security/authorization/policies#authorization-handlers)kullanıyorsa, uç nokta yönlendirmesi MVC 'den farklı bir kaynak türünü işleyicilere geçirir. Yetkilendirme işleyicisi bağlam kaynağının türünde olmasını bekleyen işleyiciler <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (( [MVC filtreleri tarafından sağlanan](xref:security/authorization/policies#access-mvc-request-context-in-handlers)kaynak türü), türündeki kaynakları işleyecek şekilde <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (bir uç nokta yönlendirmeye göre yetkilendirme işleyicilerine verilen kaynak türü) yönelik olarak güncelleştirilmeleri gerekir.

MVC hala `AuthorizationFilterContext` kaynakları kullanıyor, bu nedenle uygulama, uç nokta yönlendirme yetkilendirmesi ile bırlıkte MVC yetkilendirme filtrelerini kullanıyorsa, her iki kaynak türünü de yönetmek gerekebilir.

### SignalR

Hub 'ların eşlemesi SignalR artık içinde yer alır `UseEndpoints` .

Her hub 'ı ile eşleyin `MapHub` . Önceki sürümlerde olduğu gibi, her hub açık olarak listelenir.

Aşağıdaki örnekte, Hub için destek `ChatHub` SignalR eklenmiştir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

İstemcilerden gelen ileti boyutu sınırlarını denetlemek için yeni bir seçenek vardır. Örneğin, içinde `Startup.ConfigureServices` :

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET Core 2,2 ' de, `TransportMaxBufferSize` en büyük ileti boyutunu etkin bir şekilde denetleyebilecek ve ' yi ayarlayabilirsiniz. ASP.NET Core 3,0 ' de, bu seçenek artık yalnızca geri basınç gözlemlenmeyen en büyük boyutu denetler.

### <a name="mvc-controllers"></a>MVC denetleyicileri

Denetleyicilerin eşlemesi artık içinde yer alır `UseEndpoints` .

`MapControllers`Uygulama öznitelik yönlendirme kullanıyorsa ekleyin. Yönlendirme ASP.NET Core 3,0 veya sonraki sürümlerde birçok çerçeve için destek içerdiğinden, öznitelik yönlendirmeli denetleyiciler eklemek kabul edilir.

Şunları değiştirin:

* `MapRoute` kullanılarak `MapControllerRoute`
* `MapAreaRoute` kullanılarak `MapAreaControllerRoute`

Yönlendirme şimdi yalnızca MVC 'den daha fazlasına destek içerdiğinden, bu yöntemlerin ne yapacaklarına açık bir şekilde sahip olması için terminoloji değişmiştir. Gibi geleneksel yollar `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` eklendikleri sırayla uygulanır. Önce daha belirli yollar (örneğin, bir alana yönelik yollar) yerleştirin.

Aşağıdaki örnekte:

* `MapControllers` öznitelik yönlendirmeli denetleyiciler için destek ekler.
* `MapAreaControllerRoute` bir alanındaki denetleyiciler için geleneksel bir yol ekler.
* `MapControllerRoute` denetleyiciler için geleneksel bir yol ekler.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Denetleyici eylem adlarından zaman uyumsuz son ek kaldırma

ASP.NET Core 3,0 ' de ASP.NET Core MVC, `Async` son eki denetleyici eylem adlarından kaldırır. Hem yönlendirme hem de bağlantı oluşturma, bu yeni varsayılan değerinden etkilenir. Örneğin:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

ASP.NET Core 3,0 öncesi:

* Önceki eyleme *Ürünler/ListAsync* rotası üzerinden erişilebilir.
* Son eki belirten bağlantı oluşturma gerekiyor `Async` . Örneğin:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

ASP.NET Core 3,0:

* Yukarıdaki eyleme, *Ürünler/liste* rotasında erişilebilir.
* Bağlantı oluşturma, sonekin belirtilmesini gerektirmez `Async` . Örneğin:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Bu değişiklik, özniteliği kullanılarak belirtilen adları etkilemez [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Varsayılan davranış ' de aşağıdaki kodla devre dışı bırakılabilir `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Bağlantı oluşturma değişiklikleri

[Önceki yönlendirme sürümlerindeki farklılıklar](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)hakkında belgelerde açıklandığı gibi, bağlantı oluşturma ( `Url.Link` Örneğin ve benzer API 'ler kullanılarak) ile ilgili bazı farklılıklar vardır. Bunlar:

* Varsayılan olarak, uç nokta yönlendirme kullanılırken, üretilen URI 'Ler içindeki yol parametrelerinin büyük küçük harf korunması zorunlu değildir. Bu davranış, `IOutboundParameterTransformer` arabirimiyle denetlenebilir.
* Geçersiz bir yol (mevcut olmayan bir denetleyici/eylem veya sayfa) için URI oluşturma, geçersiz bir URI oluşturmak yerine Endpoint Routing altında boş bir dize oluşturur.
* Çevresel değerler (geçerli bağlamdaki rota parametreleri), uç nokta yönlendirme ile bağlantı oluşturmada otomatik olarak kullanılmaz. Daha önce, başka bir eyleme (veya sayfaya) bir bağlantı oluştururken, *geçerli* rota ortam değerlerinden belirtilmemiş yol değerleri çıkarsanamıyor. Endpoint Routing kullanılırken, bağlantı oluşturma sırasında tüm rota parametreleri açıkça belirtilmelidir.

### <a name="no-locrazor-pages"></a>Razor Sayfaları

Eşleme Razor sayfaları artık içinde yer alır `UseEndpoints` .

`MapRazorPages`Uygulama sayfaları kullanıyorsa ekleyin Razor . Endpoint Routing birçok çerçeve için destek içerdiğinden, sayfa ekleme Razor artık kabul edilir.

Aşağıdaki `Startup.Configure` yöntemde, `MapRazorPages` sayfalar için destek ekler Razor :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Endpoint Routing olmadan MVC kullanma

`UseMvc`ASP.NET Core 3,0 aracılığıyla veya `UseMvcWithDefaultRoute` içinde MVC kullanmanın içinde açık bir kabul olması gerekir `Startup.ConfigureServices` . Bu, MVC 'nin başlatma sırasında yetkilendirme ve CORS ara yazılımını kullanıp kullanamayacağını bilmeleri gerektiğinden gereklidir. Uygulama desteklenmeyen bir yapılandırmayı kullanmayı denerse sizi uyaran bir çözümleyici sağlanır.

Uygulama eski `IRouter` destek gerektiriyorsa, `EnableEndpointRouting` içinde aşağıdaki yaklaşımlardan herhangi birini kullanarak devre dışı bırakın `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, uç nokta yönlendirme özellikli bir *yönlendirici-yazılım* olarak kullanılabilir.

`MapHealthChecks`Uç nokta yönlendirme ile durum denetimlerini kullanmak için ekleyin. `MapHealthChecks`Yöntemi şuna benzer bağımsız değişkenleri kabul eder `UseHealthChecks` . Kullanmanın avantajı, `MapHealthChecks` `UseHealthChecks` Yetkilendirme uygulayabilir ve eşleşen ilke üzerinde daha ayrıntılı denetime sahip olabilir.

Aşağıdaki örnekte, şu `MapHealthChecks` konumda bir sistem durumu denetim uç noktası için çağrılır `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder WebHostBuilder 'ın yerini alır

ASP.NET Core 3,0 şablonları [genel konak](xref:fundamentals/host/generic-host)kullanır. Önceki sürümler [Web ana bilgisayarı](xref:fundamentals/host/web-host)kullandı. Aşağıdaki kod ASP.NET Core 3,0 şablonu oluşturulan `Program` sınıfını gösterir:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Aşağıdaki kod, ASP.NET Core 2,2 şablonu tarafından oluşturulan sınıfı gösterir `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> 3,0 ' de kalır ve `webBuilder` önceki kod örneğinde görülen öğesinin türüdür. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> gelecekteki bir sürümde kullanımdan kaldırılacak ve tarafından değiştirilmeyecektir `HostBuilder` .

' Den ' ye en önemli değişiklik, `WebHostBuilder` `HostBuilder` [bağımlılık ekleme (dı)](xref:fundamentals/dependency-injection)içinde. Kullanırken `HostBuilder` , yalnızca aşağıdakilerin `Startup` oluşturucusunu ekleyebilirsiniz:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder`Dı kısıtlamaları:

* Dı kapsayıcısının yalnızca bir kez derlenme özelliğini etkinleştirin.
* Birden çok tekton örneğini çözümlemek gibi ortaya çıkan nesne ömrü sorunlarını önler.

Daha fazla bilgi için bkz. [ASP.NET Core 3 ' te başlangıç hizmeti ekleme Işlemini önleme](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addaduthorleştirme farklı bir derlemeye taşındı

Microsoft.AspNetCore.Authorization.dllASP.NET Core 2,2 ve daha düşük `AddAuthorization` Yöntemler  :

* Yeniden adlandırıldı `AddAuthorizationCore` .
* *Microsoft.AspNetCore.Authorization.Policy.dll* taşındı.

Hem *Microsoft.AspNetCore.Authorization.dll* hem de *Microsoft.AspNetCore.Authorization.Policy.dll* kullanan uygulamalar etkilenmez.

*Microsoft.AspNetCore.Authorization.Policy.dll* kullanmayan uygulamalar aşağıdakilerden birini yapmanız gerekir:

* *Microsoft.AspNetCore.Authorization.Policy.dll* bir başvuru ekleyin. Bu yaklaşım çoğu uygulama için geçerlidir ve gereklidir.
* Kullanmaya geç `AddAuthorizationCore`

Daha fazla bilgi için bkz. [' deki Son değişiklik `AddAuthorization(o =>` ) farklı bir derlemede #386 aşırı yükleme yaşar](https://github.com/aspnet/Announcements/issues/386).

## <a name="no-locidentity-ui"></a>Identity 'SıNı

Identity ASP.NET Core 3,0 için Kullanıcı Arabirimi güncelleştirmeleri:

* [Microsoft. AspNetCore 'a bir paket başvurusu ekleyin. Identity Kullanıcı arabirimi](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Sayfaları kullanmayan uygulamaların Razor çağırması gerekir `MapRazorPages` . Bu belgedeki [ Razor sayfalara](#razor-pages) bakın.
* Bootstrap 4, varsayılan UI çerçevesidir. Varsayılan ayarı `IdentityUIFrameworkVersion` değiştirmek için bir proje özelliği ayarlayın. Daha fazla bilgi için [Bu GitHub duyurusuna](https://github.com/aspnet/Announcements/issues/380)bakın.

## SignalR

SignalRJavaScript istemcisi sürümünden `@aspnet/signalr` olarak değiştirilmiştir `@microsoft/signalr` . Bu değişikliğe tepki vermek için, dosyalar, *package.json* `require` deyimler ve ECMAScript deyimleriyle ilgilipackage.jsbaşvuruları değiştirin `import` .

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Js, varsayılan protokoldür

`System.Text.Json` , artık istemci ve sunucu tarafından kullanılan varsayılan Hub protokolüdür.

İçinde `Startup.ConfigureServices` , `AddJsonProtocol` seri hale getirici seçeneklerini ayarlamak için çağırın.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**İstemcilerinin**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft.Jsüzerine geç

Üzerinde [System.Text.Jsdesteklenmeyen Newtonsoft.JsÖzellikler](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)kullanıyorsanız, ' ye dönebilirsiniz `Newtonsoft.Json` . Bu makalenin önceki kısımlarında yer [alan ASP.NET Core 3,0 SignalR projesinde Newtonsoft.Jskullanma](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) konusuna bakın.

## <a name="redis-distributed-caches"></a>Redsıs dağıtılmış önbellekler

[Microsoft. Extensions. Caching. redsıs](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) paketi ASP.NET Core 3,0 veya üzeri uygulamalar için kullanılamaz. Paket başvurusunu [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis)ile değiştirin. Daha fazla bilgi için bkz. <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Çalışma zamanı derlemesini kabul et

ASP.NET Core 3,0 ' den önce, görünümlerin çalışma zamanı derlemesi Framework 'ün örtük bir özelliğidir. Çalışma zamanı derlemesi, görünümlerin derleme zamanı derlemesini tamamlar. Bu, Framework 'ün Razor tüm uygulamayı yeniden derlemek zorunda kalmadan görünümleri ve sayfaları ( *. cshtml* dosyaları) derleyebilmesine izin verir. Bu özellik, IDE 'de hızlı bir düzenleme yapma ve değişiklikleri görüntülemek için tarayıcıyı yenileme senaryosunu destekler.

ASP.NET Core 3,0 ' de, çalışma zamanı derlemesi bir katılım senaryosudur. Derleme zamanı derlemesi, varsayılan olarak etkinleştirilen görünüm derlemesi için tek mekanizmadır. Çalışma zamanı, *. cshtml* dosyalarında değişiklik algıladığında projeyi yeniden derlemek için Visual Studio Code Içinde Visual Studio veya [DotNet-Watch](xref:tutorials/dotnet-watch) 'u temel alır. Visual Studio 'da, çalıştırılan projedeki *. cs* , *. cshtml* veya *. Razor* dosyalarında yapılan değişiklikler ( <kbd>CTRL + F5</kbd>), ancak hata ayıklaması ( <kbd>F5</kbd>), projenin yeniden derlenmesi tetiklenemez.

ASP.NET Core 3,0 projenizde çalışma zamanı derlemesini etkinleştirmek için:

1. [Microsoft. AspNetCore. Mvc 'yi yükler. Razor RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet paketi.
1. `Startup.ConfigureServices`Çağrılacak güncelleştirme `AddRazorRuntimeCompilation` :

    ASP.NET Core MVC için aşağıdaki kodu kullanın:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    ASP.NET Core Razor sayfalar için aşağıdaki kodu kullanın:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
' Deki örnek, https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation geliştirme ortamlarında, çalışma zamanı derlemesini koşullu olarak etkinleştirmeye yönelik bir örnek gösterir.

Dosya derleme hakkında daha fazla bilgi için Razor bkz <xref:mvc/views/view-compilation> ..

## <a name="migrate-libraries-via-multi-targeting"></a>Çoklu hedefleme aracılığıyla kitaplıkları geçirme

Kitaplıklar genellikle ASP.NET Core birden çok sürümünü desteklemelidir. Önceki ASP.NET Core sürümlerine karşı derlenen kitaplıkların çoğu, sorun olmadan çalışmaya devam etmelidir. Aşağıdaki koşullar uygulamanın çapraz derlenmesi için gereklidir:

* Kitaplık, ikili bir [bölme değişikliği](#breaking-api-changes)olan bir özelliği kullanır.
* Kitaplığı ASP.NET Core 3,0 sürümündeki yeni özelliklerden faydalanmak istiyor. 

Örneğin:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

`#ifdefs`ASP.NET Core 3,0 'e özgü API 'leri etkinleştirmek için kullanın:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Bir sınıf kitaplığında ASP.NET Core API 'Leri kullanma hakkında daha fazla bilgi için bkz <xref:fundamentals/target-aspnetcore> ..

## <a name="miscellaneous-changes"></a>Çeşitli değişiklikler

.NET Core 3,0 ve sonraki sürümlerde doğrulama sistemi, null olamayan parametrelere veya bir özniteliğe sahip oldukları gibi bağlantılı özelliklere sahiptir `[Required]` . Daha fazla bilgi için bkz. [[Required] özniteliği](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Yayımlama

Proje dizinindeki *bin* ve *obj* klasörlerini silin.

## <a name="testserver"></a>TestServer

<xref:Microsoft.AspNetCore.TestHost.TestServer>Doğrudan [genel ana bilgisayar](xref:fundamentals/host/web-host)ile kullanan uygulamalar için ' `TestServer` de bir üzerinde oluşturun <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>API değişiklikleri kesiliyor

Son değişiklikleri gözden geçir:

* [ASP.NET Core 3,0 sürümündeki son değişikliklerin listesini doldurun](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Antiforgery, CORS, Diagnostics, MVC ve yönlendirme IÇINDEKI API değişiklikleri kesiliyor](https://github.com/aspnet/Announcements/issues/387). Bu liste, uyumluluk anahtarlarına yönelik son değişiklikleri içerir.
* .NET Core, ASP.NET Core ve Entity Framework Core arasında 2,2-3,0 ' e kadar olan değişiklikler hakkında bir Özet için bkz. [sürüm 2,2 ' den 3,0 ' e geçiş Için Son değişiklikler](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Catch-all parametresiyle Endpoint Routing

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>Azure App Service .NET Core 3,0

.NET Core 'un Azure App Service dağıtımı tamamlanmıştır. .NET Core 3,0 tüm Azure App Service veri merkezlerinde kullanılabilir.