---
title: ASP.NET Core 'de alt anahtar türetme ve kimliği doğrulanmış şifreleme
author: rick-anderson
description: ASP.NET Core Data Protection alt anahtar türetme ve kimliği doğrulanmış şifrelemenin uygulama ayrıntılarını öğrenin.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ':::no-loc(appsettings.json):::'
- ':::no-loc(ASP.NET Core Identity):::'
- ':::no-loc(cookie):::'
- ':::no-loc(Cookie):::'
- ':::no-loc(Blazor):::'
- ':::no-loc(Blazor Server):::'
- ':::no-loc(Blazor WebAssembly):::'
- ':::no-loc(Identity):::'
- ":::no-loc(Let's Encrypt):::"
- ':::no-loc(Razor):::'
- ':::no-loc(SignalR):::'
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: efe8ad2f71feda9cbc1693d362e30eff29cbcd74
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060163"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="52e48-103">ASP.NET Core 'de alt anahtar türetme ve kimliği doğrulanmış şifreleme</span><span class="sxs-lookup"><span data-stu-id="52e48-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="52e48-104">Anahtar halkasındaki çoğu anahtar, bir tür entropi içerir ve "CBC-Mode ENCRYPTION + HMAC doğrulaması" veya "GCM Encryption + doğrulaması" belirten algoritmik bilgilerine sahip olur.</span><span class="sxs-lookup"><span data-stu-id="52e48-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="52e48-105">Bu gibi durumlarda, bu anahtar için ana anahtar malzemesi (veya KM) olarak katıştırılmış entropi 'ye başvurduk ve gerçek şifreleme işlemleri için kullanılacak anahtarları türetmek için bir anahtar türetme işlevi gerçekleştirdik.</span><span class="sxs-lookup"><span data-stu-id="52e48-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="52e48-106">Anahtarlar soyuttur ve özel bir uygulama aşağıda belirtildiği gibi davranmayabilir.</span><span class="sxs-lookup"><span data-stu-id="52e48-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="52e48-107">Anahtar `IAuthenticatedEncryptor` yerleşik fabrikalarımızın birini kullanmak yerine kendi uygulamasını sağlıyorsa, bu bölümde açıklanan mekanizma artık geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="52e48-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="52e48-108">Ek kimliği doğrulanmış veriler ve alt anahtar türetme</span><span class="sxs-lookup"><span data-stu-id="52e48-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="52e48-109">`IAuthenticatedEncryptor`Arabirim, tüm kimliği doğrulanmış şifreleme işlemleri için çekirdek arabirim işlevi görür.</span><span class="sxs-lookup"><span data-stu-id="52e48-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="52e48-110">`Encrypt`Yöntemi iki ara bellek alır: düz metin ve Adtionalaıditeddata (AAD).</span><span class="sxs-lookup"><span data-stu-id="52e48-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="52e48-111">Düz metin içeriği, öğesine yapılan çağrıyı değiştirmez `IDataProtector.Protect` , ancak AAD sistem tarafından oluşturulur ve üç bileşenden oluşur:</span><span class="sxs-lookup"><span data-stu-id="52e48-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="52e48-112">Veri koruma sisteminin bu sürümünü tanımlayan 32-bit Magic Header 09 F0 C9 F0.</span><span class="sxs-lookup"><span data-stu-id="52e48-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="52e48-113">128 bitlik anahtar kimliği.</span><span class="sxs-lookup"><span data-stu-id="52e48-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="52e48-114">Bu işlemi gerçekleştiren, oluşturan amaç zincirinden oluşturulmuş değişken uzunluklu bir dize `IDataProtector` .</span><span class="sxs-lookup"><span data-stu-id="52e48-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="52e48-115">AAD, üç bileşenin de kayıt düzeni için benzersiz olduğundan, bunu, şifreleme işlemlerimizin tümünde KM 'yi kullanmak yerine, KM 'den yeni anahtar türetmede kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="52e48-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="52e48-116">Her çağrısı için `IAuthenticatedEncryptor.Encrypt` aşağıdaki anahtar türetme süreci gerçekleşir:</span><span class="sxs-lookup"><span data-stu-id="52e48-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="52e48-117">Burada, (bkz. [NıST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1), AŞAĞıDAKI parametrelerle NIST SP800-108 KDF 'yi arıyoruz:</span><span class="sxs-lookup"><span data-stu-id="52e48-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="52e48-118">Anahtar türetme anahtarı (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="52e48-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="52e48-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="52e48-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="52e48-120">Label = Adtionalaıseteddata</span><span class="sxs-lookup"><span data-stu-id="52e48-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="52e48-121">bağlam = contextHeader | | keyModifier</span><span class="sxs-lookup"><span data-stu-id="52e48-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="52e48-122">Bağlam üst bilgisi değişken uzunluktadır ve temelde, ve türettiğimiz algoritmaların parmak izi olarak görev yapar `K_E` `K_H` .</span><span class="sxs-lookup"><span data-stu-id="52e48-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="52e48-123">Anahtar değiştirici, her bir çağrı için rastgele oluşturulan 128 bitlik bir dizedir `Encrypt` ve bu belirli kimlik doğrulama şifreleme işlemi için, KDF 'ye yapılan diğer tüm girişler sabit olsa bile, ke ve KH 'nin bu belirli kimlik doğrulama şifreleme işlemi için benzersiz olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="52e48-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="52e48-124">CBC modu şifreleme + HMAC doğrulama işlemleri için, `| K_E |` simetrik blok şifre anahtarının uzunluğudur ve `| K_H |` HMAC yordamının Özet boyutudur.</span><span class="sxs-lookup"><span data-stu-id="52e48-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="52e48-125">GCM şifreleme + doğrulama işlemleri için `| K_H | = 0` .</span><span class="sxs-lookup"><span data-stu-id="52e48-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="52e48-126">CBC modu şifreleme + HMAC doğrulaması</span><span class="sxs-lookup"><span data-stu-id="52e48-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="52e48-127">`K_E`Yukarıdaki mekanizmayla bir kez üretildikten sonra rastgele bir başlatma vektörü oluşturur ve düz metin şifreler için simetrik blok şifre algoritmasını çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="52e48-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="52e48-128">Başlatma vektörü ve şifreli dosyalar, MAC 'i oluşturmak için anahtarla başlatılan HMAC yordamı aracılığıyla çalıştırılır `K_H` .</span><span class="sxs-lookup"><span data-stu-id="52e48-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="52e48-129">Bu işlem ve dönüş değeri aşağıda grafik olarak gösterilir.</span><span class="sxs-lookup"><span data-stu-id="52e48-129">This process and the return value is represented graphically below.</span></span>

![CBC modunda işlem ve dönüş](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="52e48-131">`IDataProtector.Protect`Uygulama, bir [MAGIC üst bilgisini ve anahtar kimliğini](xref:security/data-protection/implementation/authenticated-encryption-details) çağırana döndürmeden önce çıktıya alacak.</span><span class="sxs-lookup"><span data-stu-id="52e48-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="52e48-132">Sihirli üstbilgi ve anahtar kimliği, [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)'nin örtük bir parçası olduğundan ve anahtar değiştiricisi KDF 'ye giriş olarak beslendiği için, bu, son döndürülen yükün her bir BAYTıNıN Mac tarafından doğrulanması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="52e48-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="52e48-133">Galoa/sayaç modu şifreleme + doğrulama</span><span class="sxs-lookup"><span data-stu-id="52e48-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="52e48-134">Yukarıdaki mekanizmayla bir kez oluşturulduktan sonra `K_E` rastgele bir 96 bit nonce oluşturur ve simetrik blok şifre algoritmasını şifreler, düz metin olarak çalıştırır ve 128 bit kimlik doğrulama etiketini oluşturur.</span><span class="sxs-lookup"><span data-stu-id="52e48-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM modu işlemi ve döndürme](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="52e48-136">GCM yerel olarak AAD kavramını desteklese de, AAD parametresi için bir boş dizeyi GCM 'ye geçirmek için AAD 'yi yalnızca özgün KDF 'ye besliyoruz.</span><span class="sxs-lookup"><span data-stu-id="52e48-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="52e48-137">Bunun nedeni iki katdır.</span><span class="sxs-lookup"><span data-stu-id="52e48-137">The reason for this is two-fold.</span></span> <span data-ttu-id="52e48-138">İlk olarak, bir şekilde doğrudan şifreleme anahtarı olarak kullanmak istemediğimiz [çevikliği desteklemek için](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) `K_M` .</span><span class="sxs-lookup"><span data-stu-id="52e48-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="52e48-139">Ayrıca, GCM, girişlerinde çok sıkı benzersizlik gereksinimleri uygular.</span><span class="sxs-lookup"><span data-stu-id="52e48-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="52e48-140">GCM şifreleme yordamının, aynı (anahtar, nonce) çiftiyle iki veya daha fazla farklı giriş verisi kümesinde çağrılması olasılığı 2 ^ 32 ' yi aşmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="52e48-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="52e48-141">`K_E`2 ^-32 sınırının afoul 'i çalıştırmadan önce 2 ' den fazla ^ 32 şifreleme işlemi gerçekleştiremedik.</span><span class="sxs-lookup"><span data-stu-id="52e48-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="52e48-142">Bu çok fazla sayıda işlem gibi görünebilir, ancak yüksek trafikli bir Web sunucusu, bu anahtarların normal ömrü içinde boyutundaydı gün içinde 4.000.000.000 istek aracılığıyla değişebilir.</span><span class="sxs-lookup"><span data-stu-id="52e48-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="52e48-143">2 ^-32 olasılık limitinin uyumlu kalmasını sağlamak için, bir 128 bit anahtar değiştirici ve 96-bit nonce kullanmaya devam ediyoruz. Bu, belirli bir süre için kullanılabilir işlem sayısı düzeyini önemli ölçüde uzatır `K_M` .</span><span class="sxs-lookup"><span data-stu-id="52e48-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="52e48-144">Tasarımın basitliği için, CBC ve GCM işlemleri arasında KDF kodu yolunu paylaşıyoruz ve AAD 'nin KDF 'de zaten kabul edildiği için, bunu GCM yordamına iletmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="52e48-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
