---
title: ASP.NET Core ile aşamalı Web uygulamaları oluşturma Blazor WebAssembly
author: guardrex
description: BlazorMasaüstü uygulaması gibi davranması için modern tarayıcı özelliklerini kullanan bir tabanlı aşamalı Web uygulaması (PWA) oluşturmayı öğrenin.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 01/11/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: 1706d3502dc68f1c25e0c35ba8f5dd44b55ce690
ms.sourcegitcommit: cc405f20537484744423ddaf87bd1e7d82b6bdf0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/21/2021
ms.locfileid: "98658657"
---
# <a name="build-progressive-web-applications-with-aspnet-core-no-locblazor-webassembly"></a><span data-ttu-id="97ff0-103">ASP.NET Core ile aşamalı Web uygulamaları oluşturma Blazor WebAssembly</span><span class="sxs-lookup"><span data-stu-id="97ff0-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="97ff0-104">[Steve Sanderson](https://github.com/SteveSandersonMS) tarafından</span><span class="sxs-lookup"><span data-stu-id="97ff0-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

<span data-ttu-id="97ff0-105">Aşamalı bir Web uygulaması (PWA) genellikle modern tarayıcı API 'Leri ve masaüstü uygulaması gibi davranmaya yönelik yetenekler kullanan tek sayfalı bir uygulamadır (SPA).</span><span class="sxs-lookup"><span data-stu-id="97ff0-105">A Progressive Web Application (PWA) is usually a Single Page Application (SPA) that uses modern browser APIs and capabilities to behave like a desktop app.</span></span> <span data-ttu-id="97ff0-106">Blazor WebAssembly , standartlara dayalı bir istemci tarafı Web uygulaması platformudur, bu nedenle aşağıdaki yetenekler için gereken PWA API 'Leri de dahil olmak üzere herhangi bir tarayıcı API 'sini kullanabilir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-106">Blazor WebAssembly is a standards-based client-side web app platform, so it can use any browser API, including PWA APIs required for the following capabilities:</span></span>

* <span data-ttu-id="97ff0-107">Ağ hızından bağımsız olarak çevrimdışı çalışma ve anında yükleme.</span><span class="sxs-lookup"><span data-stu-id="97ff0-107">Working offline and loading instantly, independent of network speed.</span></span>
* <span data-ttu-id="97ff0-108">Yalnızca bir tarayıcı penceresi değil kendi uygulama penceresinde çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="97ff0-108">Running in its own app window, not just a browser window.</span></span>
* <span data-ttu-id="97ff0-109">Konağın işletim sistemi Başlat menüsünden, Dock veya Ana ekranınızdan başlatılmakta.</span><span class="sxs-lookup"><span data-stu-id="97ff0-109">Being launched from the host's operating system start menu, dock, or home screen.</span></span>
* <span data-ttu-id="97ff0-110">Kullanıcı uygulamayı kullanmıyor olsa bile, arka uç sunucusundan anında iletme bildirimleri alma.</span><span class="sxs-lookup"><span data-stu-id="97ff0-110">Receiving push notifications from a backend server, even while the user isn't using the app.</span></span>
* <span data-ttu-id="97ff0-111">Arka planda otomatik olarak güncelleştiriliyor.</span><span class="sxs-lookup"><span data-stu-id="97ff0-111">Automatically updating in the background.</span></span>

<span data-ttu-id="97ff0-112">*İlerleyen* sözcük, bu tür uygulamaları tanımlamakta kullanılır çünkü:</span><span class="sxs-lookup"><span data-stu-id="97ff0-112">The word *progressive* is used to describe such apps because:</span></span>

* <span data-ttu-id="97ff0-113">Bir Kullanıcı öncelikle uygulamayı diğer SPA gibi Web tarayıcıları içinde bulabilir ve kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-113">A user might first discover and use the app within their web browser like any other SPA.</span></span>
* <span data-ttu-id="97ff0-114">Daha sonra Kullanıcı, bu uygulamayı işletim sistemine yüklemeyi ve anında iletme bildirimlerini etkinleştirmeyi ilerler.</span><span class="sxs-lookup"><span data-stu-id="97ff0-114">Later, the user progresses to installing it in their OS and enabling push notifications.</span></span>

## <a name="create-a-project-from-the-pwa-template"></a><span data-ttu-id="97ff0-115">PWA şablonundan proje oluşturma</span><span class="sxs-lookup"><span data-stu-id="97ff0-115">Create a project from the PWA template</span></span>

# <a name="visual-studio"></a>[<span data-ttu-id="97ff0-116">Visual Studio</span><span class="sxs-lookup"><span data-stu-id="97ff0-116">Visual Studio</span></span>](#tab/visual-studio)

<span data-ttu-id="97ff0-117">Yeni bir **proje oluştur** iletişim kutusunda yeni bir **Blazor WebAssembly uygulama** oluştururken, **aşamalı Web uygulaması** onay kutusunu seçin:</span><span class="sxs-lookup"><span data-stu-id="97ff0-117">When creating a new **Blazor WebAssembly App** in the **Create a New Project** dialog, select the **Progressive Web Application** check box:</span></span>

![Visual Studio yeni proje iletişim kutusunda ' aşamalı Web uygulaması ' onay kutusu seçilidir.](progressive-web-app/_static/image1.png)

<!--

# [Visual Studio for Mac](#tab/visual-studio-mac)

-->

# <a name="visual-studio-code--net-core-cli"></a>[<span data-ttu-id="97ff0-119">Visual Studio Code/.NET Core CLI</span><span class="sxs-lookup"><span data-stu-id="97ff0-119">Visual Studio Code / .NET Core CLI</span></span>](#tab/visual-studio-code+netcore-cli)

<span data-ttu-id="97ff0-120">Anahtarıyla bir komut kabuğunda bir PWA projesi oluşturmak için aşağıdaki komutu kullanın `--pwa` :</span><span class="sxs-lookup"><span data-stu-id="97ff0-120">Use the following command to create a PWA project in a command shell with the `--pwa` switch:</span></span>

```dotnetcli
dotnet new blazorwasm -o MyBlazorPwa --pwa
```

<span data-ttu-id="97ff0-121">Yukarıdaki komutta, `-o|--output` seçeneği adlı uygulama için yeni bir klasör oluşturur `MyBlazorPwa` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-121">In the preceding command, the `-o|--output` option creates a new folder for the app named `MyBlazorPwa`.</span></span>

---

<span data-ttu-id="97ff0-122">İsteğe bağlı olarak, ASP.NET Core barındırılan şablondan oluşturulan bir uygulama için PWA yapılandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-122">Optionally, PWA can be configured for an app created from the ASP.NET Core Hosted template.</span></span> <span data-ttu-id="97ff0-123">PWA senaryosu barındırma modelinden bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-123">The PWA scenario is independent of the hosting model.</span></span>

## <a name="convert-an-existing-no-locblazor-webassembly-app-into-a-pwa"></a><span data-ttu-id="97ff0-124">Mevcut bir Blazor WebAssembly uygulamayı PWA 'ya dönüştürme</span><span class="sxs-lookup"><span data-stu-id="97ff0-124">Convert an existing Blazor WebAssembly app into a PWA</span></span>

<span data-ttu-id="97ff0-125">Blazor WebAssemblyBu bölümdeki kılavuzdan sonra mevcut bir uygulamayı PWA 'ya dönüştürün.</span><span class="sxs-lookup"><span data-stu-id="97ff0-125">Convert an existing Blazor WebAssembly app into a PWA following the guidance in this section.</span></span>

<span data-ttu-id="97ff0-126">Uygulamanın proje dosyasında:</span><span class="sxs-lookup"><span data-stu-id="97ff0-126">In the app's project file:</span></span>

* <span data-ttu-id="97ff0-127">Aşağıdaki `ServiceWorkerAssetsManifest` özelliği bir öğesine ekleyin `PropertyGroup` :</span><span class="sxs-lookup"><span data-stu-id="97ff0-127">Add the following `ServiceWorkerAssetsManifest` property to a `PropertyGroup`:</span></span>

  ```xml
    ...
    <ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
  </PropertyGroup>
   ```

* <span data-ttu-id="97ff0-128">Şu `ServiceWorker` öğeyi bir öğesine ekleyin `ItemGroup` :</span><span class="sxs-lookup"><span data-stu-id="97ff0-128">Add the following `ServiceWorker` item to an `ItemGroup`:</span></span>

  ```xml
  <ItemGroup>
    <ServiceWorker Include="wwwroot\service-worker.js" 
      PublishedContent="wwwroot\service-worker.published.js" />
  </ItemGroup>
  ```

<span data-ttu-id="97ff0-129">Statik varlıkları almak için aşağıdaki yaklaşımlardan **birini** kullanın:</span><span class="sxs-lookup"><span data-stu-id="97ff0-129">To obtain static assets, use **one** of the following approaches:</span></span>

::: moniker range=">= aspnetcore-5.0"

* <span data-ttu-id="97ff0-130">Komut kabuğunda komutuyla ayrı, yeni bir PWA projesi oluşturun [`dotnet new`](/dotnet/core/tools/dotnet-new) :</span><span class="sxs-lookup"><span data-stu-id="97ff0-130">Create a separate, new PWA project with the [`dotnet new`](/dotnet/core/tools/dotnet-new) command in a command shell:</span></span>

  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa
  ```
  
  <span data-ttu-id="97ff0-131">Yukarıdaki komutta, `-o|--output` seçeneği adlı uygulama için yeni bir klasör oluşturur `MyBlazorPwa` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-131">In the preceding command, the `-o|--output` option creates a new folder for the app named `MyBlazorPwa`.</span></span>
  
  <span data-ttu-id="97ff0-132">En son sürüm için bir uygulamayı dönüştürmezseniz, `-f|--framework` seçeneğini geçirin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-132">If you aren't converting an app for the latest release, pass the `-f|--framework` option.</span></span> <span data-ttu-id="97ff0-133">Aşağıdaki örnek, ASP.NET Core sürüm 3,1 için uygulama oluşturur:</span><span class="sxs-lookup"><span data-stu-id="97ff0-133">The following example creates the app for ASP.NET Core version 3.1:</span></span>
  
  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa -f netcoreapp3.1
  ```

* <span data-ttu-id="97ff0-134">Aşağıdaki URL 'de bulunan ASP.NET Core GitHub deposuna gidin ve 5,0 yayın başvuru kaynağına ve varlıklarına bağlantı sağlar.</span><span class="sxs-lookup"><span data-stu-id="97ff0-134">Navigate to the ASP.NET Core GitHub repository at the following URL, which links to 5.0 release reference source and assets.</span></span> <span data-ttu-id="97ff0-135">5,0 sürümü için bir uygulamayı dönüştürmemişse, uygulamanız için geçerli olan **anahtar dalları veya Etiketler** açılır listesinden çalıştığınız yayını seçin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-135">If you aren't converting an app for the 5.0 release, select the release that you're working with from the **Switch branches or tags** drop-down list that applies to your app.</span></span>

  [<span data-ttu-id="97ff0-136">DotNet/aspnetcore (Release 5,0) Blazor WebAssembly proje şablonu `wwwroot` klasörü</span><span class="sxs-lookup"><span data-stu-id="97ff0-136">dotnet/aspnetcore (release 5.0) Blazor WebAssembly project template `wwwroot` folder</span></span>](https://github.com/dotnet/aspnetcore/tree/release/5.0/src/ProjectTemplates/Web.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

::: moniker-end

::: moniker range="< aspnetcore-5.0"

* <span data-ttu-id="97ff0-137">Komut kabuğunda komutuyla ayrı, yeni bir PWA projesi oluşturun [`dotnet new`](/dotnet/core/tools/dotnet-new) .</span><span class="sxs-lookup"><span data-stu-id="97ff0-137">Create a separate, new PWA project with the [`dotnet new`](/dotnet/core/tools/dotnet-new) command in a command shell.</span></span> <span data-ttu-id="97ff0-138">`-f|--framework`Sürümü seçmek için bu seçeneği geçirin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-138">Pass the `-f|--framework` option to select the version.</span></span> <span data-ttu-id="97ff0-139">Aşağıdaki örnek, ASP.NET Core sürüm 3,1 için uygulama oluşturur:</span><span class="sxs-lookup"><span data-stu-id="97ff0-139">The following example creates the app for ASP.NET Core version 3.1:</span></span>
  
  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa -f netcoreapp3.1
  ```
  
  <span data-ttu-id="97ff0-140">Yukarıdaki komutta, `-o|--output` seçeneği adlı uygulama için yeni bir klasör oluşturur `MyBlazorPwa` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-140">In the preceding command, the `-o|--output` option creates a new folder for the app named `MyBlazorPwa`.</span></span>

* <span data-ttu-id="97ff0-141">Aşağıdaki URL 'de bulunan ASP.NET Core GitHub deposuna gidin ve 3,1 yayın başvuru kaynağına ve varlıklarına bağlantı sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ff0-141">Navigate to the ASP.NET Core GitHub repository at the following URL, which links to 3.1 release reference source and assets:</span></span>

  [<span data-ttu-id="97ff0-142">DotNet/aspnetcore (Release 3,1) Blazor WebAssembly proje şablonu `wwwroot` klasörü</span><span class="sxs-lookup"><span data-stu-id="97ff0-142">dotnet/aspnetcore (release 3.1) Blazor WebAssembly project template `wwwroot` folder</span></span>](https://github.com/dotnet/aspnetcore/tree/release/3.1/src/ProjectTemplates/ComponentsWebAssembly.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

  > [!NOTE]
  > <span data-ttu-id="97ff0-143">Blazor WebAssemblyProje şablonu URL 'si ASP.NET Core 3,1 yayımlandıktan sonra değişti.</span><span class="sxs-lookup"><span data-stu-id="97ff0-143">The URL for Blazor WebAssembly project template changed after the release of ASP.NET Core 3.1.</span></span> <span data-ttu-id="97ff0-144">5,0 veya üzeri için başvuru varlıkları Şu URL 'de kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-144">Reference assets for 5.0 or later are available at the following URL:</span></span>
  >
  > [<span data-ttu-id="97ff0-145">DotNet/aspnetcore (Release 5,0) Blazor WebAssembly proje şablonu `wwwroot` klasörü</span><span class="sxs-lookup"><span data-stu-id="97ff0-145">dotnet/aspnetcore (release 5.0) Blazor WebAssembly project template `wwwroot` folder</span></span>](https://github.com/dotnet/aspnetcore/tree/release/5.0/src/ProjectTemplates/Web.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

::: moniker-end

<span data-ttu-id="97ff0-146">`wwwroot`Oluşturduğunuz uygulamada veya GitHub deposundaki başvuru varlıklarından kaynak klasörden `dotnet/aspnetcore` , aşağıdaki dosyaları uygulamanın `wwwroot` klasörüne kopyalayın:</span><span class="sxs-lookup"><span data-stu-id="97ff0-146">From the source `wwwroot` folder either in the app that you created or from the reference assets in the `dotnet/aspnetcore` GitHub repository, copy the following files into the app's `wwwroot` folder:</span></span>

* `icon-512.png`
* `manifest.json`
* `service-worker.js`
* `service-worker.published.js`

<span data-ttu-id="97ff0-147">Uygulamanın `wwwroot/index.html` dosyasında:</span><span class="sxs-lookup"><span data-stu-id="97ff0-147">In the app's `wwwroot/index.html` file:</span></span>

* <span data-ttu-id="97ff0-148">`<link>`Bildirim ve uygulama simgesi için öğeler ekleme:</span><span class="sxs-lookup"><span data-stu-id="97ff0-148">Add `<link>` elements for the manifest and app icon:</span></span>

  ```html
  <link href="manifest.json" rel="manifest" />
  <link rel="apple-touch-icon" sizes="512x512" href="icon-512.png" />
  ```

* <span data-ttu-id="97ff0-149">Aşağıdaki etiketi, `<script>` `</body>` komut dosyası etiketinin hemen ardından kapanış etiketinin içine ekleyin `blazor.webassembly.js` :</span><span class="sxs-lookup"><span data-stu-id="97ff0-149">Add the following `<script>` tag inside the closing `</body>` tag immediately after the `blazor.webassembly.js` script tag:</span></span>

  ```html
      ...
      <script>navigator.serviceWorker.register('service-worker.js');</script>
  </body>
  ```

## <a name="installation-and-app-manifest"></a><span data-ttu-id="97ff0-150">Yükleme ve uygulama bildirimi</span><span class="sxs-lookup"><span data-stu-id="97ff0-150">Installation and app manifest</span></span>

<span data-ttu-id="97ff0-151">PWA şablonu kullanılarak oluşturulan bir uygulamayı ziyaret ederken, kullanıcılar uygulamayı işletim sistemi başlangıç menüsüne, Dock 'a veya ana ekrana yükleme seçeneğine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-151">When visiting an app created using the PWA template, users have the option of installing the app into their OS's start menu, dock, or home screen.</span></span> <span data-ttu-id="97ff0-152">Bu seçeneğin sunulma şekli kullanıcının tarayıcısına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-152">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="97ff0-153">Edge veya Chrome gibi Desktop Kmıum tabanlı tarayıcıları kullanılırken, URL çubuğu içinde bir **Ekle** düğmesi görünür.</span><span class="sxs-lookup"><span data-stu-id="97ff0-153">When using desktop Chromium-based browsers, such as Edge or Chrome, an **Add** button appears within the URL bar.</span></span> <span data-ttu-id="97ff0-154">Kullanıcı **Ekle** düğmesini seçtikten sonra bir onay iletişim kutusu alırlar:</span><span class="sxs-lookup"><span data-stu-id="97ff0-154">After the user selects the **Add** button, they receive a confirmation dialog:</span></span>

![Google Chrome 'daki onay iletişim kutusu kullanıcıya ' My::: No-Loc (Blazor):::P WA ' uygulaması için bir Install düğmesi sunar.](progressive-web-app/_static/image2.png)

<span data-ttu-id="97ff0-156">İOS 'ta, ziyaretçiler Safari 'nin **Share** düğmesini ve **Add to HOMESCREEN** seçeneğini kullanarak PWA 'yı yükleyebilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-156">On iOS, visitors can install the PWA using Safari's **Share** button and its **Add to Homescreen** option.</span></span> <span data-ttu-id="97ff0-157">Android için Chrome 'da kullanıcılar, sağ üst köşedeki **menü** düğmesini ve ardından **Giriş ekranına Ekle**' yi seçer.</span><span class="sxs-lookup"><span data-stu-id="97ff0-157">On Chrome for Android, users should select the **Menu** button in the upper-right corner, followed by **Add to Home screen**.</span></span>

<span data-ttu-id="97ff0-158">Yüklendikten sonra uygulama, adres çubuğu olmadan kendi penceresinde görünür:</span><span class="sxs-lookup"><span data-stu-id="97ff0-158">Once installed, the app appears in its own window without an address bar:</span></span>

![' My::: No-Loc (Blazor):::P WA ' uygulaması, bir adres çubuğu olmadan Google Chrome 'da çalışır.](progressive-web-app/_static/image3.png)

<span data-ttu-id="97ff0-160">Pencerenin başlığını, renk şemasını, simgesini veya diğer ayrıntıları özelleştirmek için `manifest.json` projenin dizinindeki dosyasına bakın `wwwroot` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-160">To customize the window's title, color scheme, icon, or other details, see the `manifest.json` file in the project's `wwwroot` directory.</span></span> <span data-ttu-id="97ff0-161">Bu dosyanın şeması Web standartları tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-161">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="97ff0-162">Daha fazla bilgi için bkz. [MDN Web belgeleri: Web uygulaması bildirimi](https://developer.mozilla.org/docs/Web/Manifest).</span><span class="sxs-lookup"><span data-stu-id="97ff0-162">For more information, see [MDN web docs: Web App Manifest](https://developer.mozilla.org/docs/Web/Manifest).</span></span>

## <a name="offline-support"></a><span data-ttu-id="97ff0-163">Çevrimdışı destek</span><span class="sxs-lookup"><span data-stu-id="97ff0-163">Offline support</span></span>

<span data-ttu-id="97ff0-164">Varsayılan olarak, PWA şablonu seçeneği kullanılarak oluşturulan uygulamalar, çevrimdışı çalışmaya yönelik desteğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-164">By default, apps created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="97ff0-165">Bir kullanıcının çevrimiçi olduklarında uygulamayı ilk kez ziyaret etmelidir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-165">A user must first visit the app while they're online.</span></span> <span data-ttu-id="97ff0-166">Tarayıcı, çevrimdışı çalışmak için gereken tüm kaynakları otomatik olarak indirir ve önbelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-166">The browser automatically downloads and caches all of the resources required to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="97ff0-167">Geliştirme desteği, değişiklik yapma ve test etme işlemleri için olağan geliştirme döngüsünü kesintiye uğratıyor.</span><span class="sxs-lookup"><span data-stu-id="97ff0-167">Development support would interfere with the usual development cycle of making changes and testing them.</span></span> <span data-ttu-id="97ff0-168">Bu nedenle, çevrimdışı destek yalnızca *yayımlanan* uygulamalar için etkinleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-168">Therefore, offline support is only enabled for *published* apps.</span></span> 

> [!WARNING]
> <span data-ttu-id="97ff0-169">Çevrimdışı etkin bir PWA dağıtmak istiyorsanız, [bazı önemli uyarılar ve uyarılar](#caveats-for-offline-pwas)vardır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-169">If you intend to distribute an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas).</span></span> <span data-ttu-id="97ff0-170">Bu senaryolar, ' ye özgü olmayan çevrimdışı PWAs 'a ait değildir Blazor .</span><span class="sxs-lookup"><span data-stu-id="97ff0-170">These scenarios are inherent to offline PWAs and not specific to Blazor.</span></span> <span data-ttu-id="97ff0-171">Çevrimdışı etkin uygulamanızın nasıl çalıştığı hakkında varsayımlar yapmadan önce bu uyarıları okuduğunuzdan ve anladığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="97ff0-171">Be sure to read and understand these caveats before making assumptions about how your offline-enabled app will work.</span></span>

<span data-ttu-id="97ff0-172">Çevrimdışı desteğin nasıl çalıştığını görmek için:</span><span class="sxs-lookup"><span data-stu-id="97ff0-172">To see how offline support works:</span></span>

1. <span data-ttu-id="97ff0-173">Uygulamayı yayımlayın.</span><span class="sxs-lookup"><span data-stu-id="97ff0-173">Publish the app.</span></span> <span data-ttu-id="97ff0-174">Daha fazla bilgi için bkz. <xref:blazor/host-and-deploy/index#publish-the-app>.</span><span class="sxs-lookup"><span data-stu-id="97ff0-174">For more information, see <xref:blazor/host-and-deploy/index#publish-the-app>.</span></span>
1. <span data-ttu-id="97ff0-175">Uygulamayı HTTPS 'yi destekleyen bir sunucuya dağıtın ve uygulamayı güvenli HTTPS adresinde bir tarayıcıda erişin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-175">Deploy the app to a server that supports HTTPS, and access the app in a browser at its secure HTTPS address.</span></span>
1. <span data-ttu-id="97ff0-176">Tarayıcının geliştirme araçlarını açın ve **uygulama** sekmesinde bir *hizmet çalışanının* konak için kayıtlı olduğunu doğrulayın:</span><span class="sxs-lookup"><span data-stu-id="97ff0-176">Open the browser's dev tools and verify that a *Service Worker* is registered for the host on the **Application** tab:</span></span>

   ![Google Chrome Geliştirici Araçları ' uygulama ' sekmesi, etkinleştirilen ve çalışan bir hizmet çalışanını gösterir.](progressive-web-app/_static/image4.png)

1. <span data-ttu-id="97ff0-178">Sayfayı yeniden yükleyin ve **ağ** sekmesini Inceleyin. **hizmet çalışanı** veya **bellek önbelleği** , tüm sayfa varlıklarının kaynakları olarak listelenir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-178">Reload the page and examine the **Network** tab. **Service Worker** or **memory cache** are listed as the sources for all of the page's assets:</span></span>

   ![Tüm sayfa varlıklarının kaynaklarını gösteren Google Chrome Geliştirici Araçları ' ağ ' sekmesi.](progressive-web-app/_static/image5.png)

1. <span data-ttu-id="97ff0-180">Tarayıcının, uygulamayı yüklemek için ağ erişimi 'ne bağımlı olmadığını doğrulamak için şunlardan birini yapın:</span><span class="sxs-lookup"><span data-stu-id="97ff0-180">To verify that the browser isn't dependent on network access to load the app, either:</span></span>

   * <span data-ttu-id="97ff0-181">Web sunucusunu kapatın ve sayfa yeniden yükler dahil uygulamanın normal şekilde çalışmaya devam ettiğini görün.</span><span class="sxs-lookup"><span data-stu-id="97ff0-181">Shut down the web server and see how the app continues to function normally, which includes page reloads.</span></span> <span data-ttu-id="97ff0-182">Benzer şekilde, yavaş bir ağ bağlantısı olduğunda uygulama normal şekilde çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="97ff0-182">Likewise, the app continues to function normally when there's a slow network connection.</span></span>
   * <span data-ttu-id="97ff0-183">**Ağ** sekmesinde çevrimdışı modunun benzetimini yapmak için tarayıcıya bildirin:</span><span class="sxs-lookup"><span data-stu-id="97ff0-183">Instruct the browser to simulate offline mode in the **Network** tab:</span></span>

   ![Tarayıcı modu açılan, ' çevrimiçi ' iken ' Çevrimdışı ' olarak değiştirilen Google Chrome Geliştirici Araçları ' Ağı ' sekmesi.](progressive-web-app/_static/image6.png)

<span data-ttu-id="97ff0-185">Hizmet çalışanı kullanan çevrimdışı destek, için özel olmayan bir web standardıdır Blazor .</span><span class="sxs-lookup"><span data-stu-id="97ff0-185">Offline support using a service worker is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="97ff0-186">Hizmet çalışanları hakkında daha fazla bilgi için bkz. [MDN Web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span><span class="sxs-lookup"><span data-stu-id="97ff0-186">For more information on service workers, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span> <span data-ttu-id="97ff0-187">Hizmet çalışanları için ortak kullanım desenleri hakkında daha fazla bilgi için bkz. [Google Web: hizmet çalışanı yaşam döngüsü](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span><span class="sxs-lookup"><span data-stu-id="97ff0-187">To learn more about common usage patterns for service workers, see [Google Web: The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

<span data-ttu-id="97ff0-188">Blazoröğesinin PWA şablonu iki hizmet çalışanı dosyası üretir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-188">Blazor's PWA template produces two service worker files:</span></span>

* <span data-ttu-id="97ff0-189">`wwwroot/service-worker.js`geliştirme sırasında kullanılan.</span><span class="sxs-lookup"><span data-stu-id="97ff0-189">`wwwroot/service-worker.js`, which is used during development.</span></span>
* <span data-ttu-id="97ff0-190">`wwwroot/service-worker.published.js`, uygulama yayımlandıktan sonra kullanılır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-190">`wwwroot/service-worker.published.js`, which is used after the app is published.</span></span>

<span data-ttu-id="97ff0-191">İki hizmet çalışanı dosyası arasındaki mantığı paylaşmak için aşağıdaki yaklaşımı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="97ff0-191">To share logic between the two service worker files, consider the following approach:</span></span>

* <span data-ttu-id="97ff0-192">Ortak mantığı barındırmak için üçüncü bir JavaScript dosyası ekleyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-192">Add a third JavaScript file to hold the common logic.</span></span>
* <span data-ttu-id="97ff0-193">[`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts)Ortak mantığı her iki hizmet çalışanı dosyasına yüklemek için kullanın.</span><span class="sxs-lookup"><span data-stu-id="97ff0-193">Use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load the common logic into both service worker files.</span></span>

### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="97ff0-194">Cache-ilk getirme stratejisi</span><span class="sxs-lookup"><span data-stu-id="97ff0-194">Cache-first fetch strategy</span></span>

<span data-ttu-id="97ff0-195">Yerleşik `service-worker.published.js` hizmet çalışanı istekleri *önbelleğe alma* stratejisi kullanarak çözer.</span><span class="sxs-lookup"><span data-stu-id="97ff0-195">The built-in `service-worker.published.js` service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="97ff0-196">Bu, kullanıcının ağ erişimi mi yoksa daha yeni içerik mi olduğunu bağımsız olarak, hizmet çalışanının önbelleğe alınmış içeriği döndürmeyi tercih ettiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-196">This means that the service worker prefers to return cached content, regardless of whether the user has network access or newer content is available on the server.</span></span>

<span data-ttu-id="97ff0-197">Önbellek-ilk strateji, şu nedenle değerlidir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-197">The cache-first strategy is valuable because:</span></span>

* <span data-ttu-id="97ff0-198">**Güvenilirlik sağlar.**</span><span class="sxs-lookup"><span data-stu-id="97ff0-198">**It ensures reliability.**</span></span> <span data-ttu-id="97ff0-199">Ağ erişimi Boolean bir durum değil.</span><span class="sxs-lookup"><span data-stu-id="97ff0-199">Network access isn't a boolean state.</span></span> <span data-ttu-id="97ff0-200">Kullanıcı yalnızca çevrimiçi veya çevrimdışı değildir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-200">A user isn't simply online or offline:</span></span>

  * <span data-ttu-id="97ff0-201">Kullanıcının cihazı çevrimiçi olduğunu varsayabilir, ancak ağ bu kadar yavaş olabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-201">The user's device may assume it's online, but the network might be so slow as to be impractical to wait for.</span></span>
  * <span data-ttu-id="97ff0-202">Ağ, bazı istekleri engelleyen veya yeniden yönlendirmekte olan bir açıklamalı WIFI portalı olduğunda olduğu gibi belirli URL 'Ler için geçersiz sonuçlar döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-202">The network might return invalid results for certain URLs, such as when there's a captive WIFI portal that's currently blocking or redirecting certain requests.</span></span>
  
  <span data-ttu-id="97ff0-203">Bunun nedeni tarayıcının `navigator.onLine` API 'sinin güvenilir olmaması ve bağımlı olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-203">This is why the browser's `navigator.onLine` API isn't reliable and shouldn't be depended upon.</span></span>

* <span data-ttu-id="97ff0-204">**Doğruluk sağlar.**</span><span class="sxs-lookup"><span data-stu-id="97ff0-204">**It ensures correctness.**</span></span> <span data-ttu-id="97ff0-205">Bir çevrimdışı kaynak önbelleği oluştururken hizmet çalışanı, kaynakların tek bir anında tam ve otomatik tutarlı bir anlık görüntüsünü döndürüldüğünü güvence altına almak için içerik karmaını kullanır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-205">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="97ff0-206">Bu önbellek daha sonra atomik birim olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-206">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="97ff0-207">Yalnızca daha önce önbelleğe alınmış olan sürümler olduğundan, ağı yeni kaynaklar için soran bir nokta yoktur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-207">There's no point asking the network for newer resources, since the only versions required are the ones already cached.</span></span> <span data-ttu-id="97ff0-208">Diğer risk tutarsızlığı ve uyumsuzluk (örneğin, birlikte derlenmeyen .NET derlemelerinin sürümlerini kullanmaya çalışmak).</span><span class="sxs-lookup"><span data-stu-id="97ff0-208">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that weren't compiled together).</span></span>

### <a name="background-updates"></a><span data-ttu-id="97ff0-209">Arka plan güncelleştirmeleri</span><span class="sxs-lookup"><span data-stu-id="97ff0-209">Background updates</span></span>

<span data-ttu-id="97ff0-210">Bir akıl modeli olarak, yüklenebilen bir mobil uygulama gibi davranan bir çevrimdışı ilk PWA 'yı düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="97ff0-210">As a mental model, you can think of an offline-first PWA as behaving like a mobile app that can be installed.</span></span> <span data-ttu-id="97ff0-211">Uygulama, ağ bağlantısından bağımsız olarak hemen başlatılır, ancak yüklü uygulama mantığı, en son sürüm olmayan bir noktadan itibaren anlık görüntüden gelir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-211">The app starts up immediately regardless of network connectivity, but the installed app logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="97ff0-212">BlazorPWA şablonu, Kullanıcı her ziyaret ettiğinde ve çalışan bir ağ bağlantısı olduğunda kendiliğinden otomatik olarak güncelleştirmeyi deneyen uygulamalar üretir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-212">The Blazor PWA template produces apps that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="97ff0-213">Bu şekilde çalışma şekli şöyledir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-213">The way this works is as follows:</span></span>

* <span data-ttu-id="97ff0-214">Derleme sırasında, proje bir *hizmet çalışanı varlık bildirimi* oluşturur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-214">During compilation, the project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="97ff0-215">Varsayılan olarak, bu çağırılır `service-worker-assets.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-215">By default, this is called `service-worker-assets.js`.</span></span> <span data-ttu-id="97ff0-216">Bildirim, uygulamanın, içerik karmaları dahil .NET derlemeleri, JavaScript dosyaları ve CSS gibi çevrimdışı çalışması için gereken tüm statik kaynakları listeler.</span><span class="sxs-lookup"><span data-stu-id="97ff0-216">The manifest lists all the static resources that the app requires to function offline, such as .NET assemblies, JavaScript files, and CSS, including their content hashes.</span></span> <span data-ttu-id="97ff0-217">Kaynak listesi, hangi kaynakların önbellekte olduğunu bilmesi için hizmet çalışanı tarafından yüklenir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-217">The resource list is loaded by the service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="97ff0-218">Kullanıcı uygulamayı her ziyaret ettiğinde, tarayıcı yeniden istekleri `service-worker.js` ve `service-worker-assets.js` arka planda.</span><span class="sxs-lookup"><span data-stu-id="97ff0-218">Each time the user visits the app, the browser re-requests `service-worker.js` and `service-worker-assets.js` in the background.</span></span> <span data-ttu-id="97ff0-219">Dosyalar, mevcut yüklü hizmet çalışanı ile bayt için bayt olarak karşılaştırılır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-219">The files are compared byte-for-byte with the existing installed service worker.</span></span> <span data-ttu-id="97ff0-220">Sunucu, bu dosyalardan herhangi biri için değiştirilen içerik döndürürse, hizmet çalışanı kendi yeni bir sürümünü yüklemeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-220">If the server returns changed content for either of these files, the service worker attempts to install a new version of itself.</span></span>
* <span data-ttu-id="97ff0-221">Yeni bir sürümü yüklenirken, hizmet çalışanı çevrimdışı kaynaklar için yeni, ayrı bir önbellek oluşturur ve önbelleğin ' de listelenen kaynaklarla doldurulmasına başlar `service-worker-assets.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-221">When installing a new version of itself, the service worker creates a new, separate cache for offline resources and starts populating the cache with resources listed in `service-worker-assets.js`.</span></span> <span data-ttu-id="97ff0-222">Bu mantık `onInstall` içindeki işlevinde uygulanır `service-worker.published.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-222">This logic is implemented in the `onInstall` function inside `service-worker.published.js`.</span></span>
* <span data-ttu-id="97ff0-223">Tüm kaynaklar hatasız olarak yüklendiğinde ve tüm içerik karmalarının eşleşmesi durumunda işlem başarıyla tamamlanır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-223">The process completes successfully when all of the resources are loaded without error and all content hashes match.</span></span> <span data-ttu-id="97ff0-224">Başarılı olursa, yeni hizmet çalışanı *etkinleştirme durumunu bekliyor* olarak girer.</span><span class="sxs-lookup"><span data-stu-id="97ff0-224">If successful, the new service worker enters a *waiting for activation* state.</span></span> <span data-ttu-id="97ff0-225">Kullanıcı uygulamayı kapatır (uygulama sekmeleri veya pencereler olmadan), yeni hizmet çalışanı *etkin* hale gelir ve sonraki uygulama ziyaretleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-225">As soon as the user closes the app (no remaining app tabs or windows), the new service worker becomes *active* and is used for subsequent app visits.</span></span> <span data-ttu-id="97ff0-226">Eski hizmet çalışanı ve önbelleği silinir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-226">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="97ff0-227">İşlem başarıyla tamamlanmazsa, yeni hizmet çalışanı örneği atılır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-227">If the process doesn't complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="97ff0-228">İstemci, istekleri tamamlayabildikleri daha iyi bir ağ bağlantısına sahip olduğunda, bu güncelleştirme işlemi kullanıcının sonraki ziyaretinin üzerinde yeniden denenir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-228">The update process is attempted again on the user's next visit, when hopefully the client has a better network connection that can complete the requests.</span></span>

<span data-ttu-id="97ff0-229">Bu işlemi, hizmet çalışan mantığını düzenleyerek özelleştirin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-229">Customize this process by editing the service worker logic.</span></span> <span data-ttu-id="97ff0-230">Önceki davranışın hiçbiri öğesine özgü değildir Blazor ancak yalnızca PWA şablonu seçeneği tarafından belirtilen varsayılan deneyimdir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-230">None of the preceding behavior is specific to Blazor but is merely the default experience provided by the PWA template option.</span></span> <span data-ttu-id="97ff0-231">Daha fazla bilgi için bkz. [MDN Web belgeleri: hizmet çalışanı API 'si](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span><span class="sxs-lookup"><span data-stu-id="97ff0-231">For more information, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span>

### <a name="how-requests-are-resolved"></a><span data-ttu-id="97ff0-232">İsteklerin çözümlenmesi</span><span class="sxs-lookup"><span data-stu-id="97ff0-232">How requests are resolved</span></span>

<span data-ttu-id="97ff0-233">[Önbellek-ilk getirme stratejisi](#cache-first-fetch-strategy) bölümünde açıklandığı gibi, varsayılan hizmet çalışanı bir *ön uç* stratejisi kullanır, yani kullanılabilir olduğunda önbelleğe alınmış içeriklere hizmet vermeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-233">As described in the [Cache-first fetch strategy](#cache-first-fetch-strategy) section, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="97ff0-234">Belirli bir URL için önbelleğe alınmış içerik yoksa (örneğin, arka uç API 'sinden veri istenirken), hizmet çalışanı normal bir ağ isteğine geri döner.</span><span class="sxs-lookup"><span data-stu-id="97ff0-234">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request.</span></span> <span data-ttu-id="97ff0-235">Sunucu ulaşılabilir olduğunda ağ isteği başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-235">The network request succeeds if the server is reachable.</span></span> <span data-ttu-id="97ff0-236">Bu mantık `onFetch` içindeki işlevinin içinde uygulanır `service-worker.published.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-236">This logic is implemented inside `onFetch` function within `service-worker.published.js`.</span></span>

<span data-ttu-id="97ff0-237">Uygulamanın Razor bileşenleri, arka uç API 'lerinden veri istemeyi ve ağ kullanım dışı nedenlerle başarısız istekler için kolay bir kullanıcı deneyimi sağlamak istiyorsanız, uygulamanın bileşenleri içinde Logic uygulayın.</span><span class="sxs-lookup"><span data-stu-id="97ff0-237">If the app's Razor components rely on requesting data from backend APIs and you want to provide a friendly user experience for failed requests due to network unavailability, implement logic within the app's components.</span></span> <span data-ttu-id="97ff0-238">Örneğin, `try/catch` istekleri etrafında kullanın <xref:System.Net.Http.HttpClient> .</span><span class="sxs-lookup"><span data-stu-id="97ff0-238">For example, use `try/catch` around <xref:System.Net.Http.HttpClient> requests.</span></span>

### <a name="support-server-rendered-pages"></a><span data-ttu-id="97ff0-239">Sunucu tarafından işlenen sayfaları destekleme</span><span class="sxs-lookup"><span data-stu-id="97ff0-239">Support server-rendered pages</span></span>

<span data-ttu-id="97ff0-240">Kullanıcı, veya gibi bir URL 'ye ilk kez gittiğinde ne olacağını göz önünde bulundurun `/counter` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-240">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link in the app.</span></span> <span data-ttu-id="97ff0-241">Bu durumlarda, olarak önbelleğe alınmış içeriği döndürmek istemezsiniz `/counter` , bunun yerine `/index.html` uygulamanızı başlatmak için tarayıcıda önbelleğe alınmış içeriği yüklemesi gerekir Blazor WebAssembly .</span><span class="sxs-lookup"><span data-stu-id="97ff0-241">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly app.</span></span> <span data-ttu-id="97ff0-242">Bu ilk istekler, şu şekilde *Gezinti* istekleri olarak bilinir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-242">These initial requests are known as *navigation* requests, as opposed to:</span></span>

* <span data-ttu-id="97ff0-243">`subresource` görüntüler, stil sayfaları veya diğer dosyalar için istekler.</span><span class="sxs-lookup"><span data-stu-id="97ff0-243">`subresource` requests for images, stylesheets, or other files.</span></span>
* <span data-ttu-id="97ff0-244">`fetch/XHR` API verisi istekleri.</span><span class="sxs-lookup"><span data-stu-id="97ff0-244">`fetch/XHR` requests for API data.</span></span>

<span data-ttu-id="97ff0-245">Varsayılan hizmet çalışanı, gezinti istekleri için özel durum mantığı içerir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-245">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="97ff0-246">Hizmet çalışanı, istenen URL 'den bağımsız olarak, için önbelleğe alınmış içeriği döndürerek istekleri çözer `/index.html` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-246">The service worker resolves the requests by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="97ff0-247">Bu mantık `onFetch` içindeki işlevinde uygulanır `service-worker.published.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-247">This logic is implemented in the `onFetch` function inside `service-worker.published.js`.</span></span>

<span data-ttu-id="97ff0-248">Uygulamanızda sunucu tarafından işlenmiş HTML döndürmesi gereken belirli URL 'Ler varsa ve önbellekten hizmet vermezse `/index.html` , hizmet çalışanınızdaki mantığı düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-248">If your app has certain URLs that must return server-rendered HTML, and not serve `/index.html` from the cache, then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="97ff0-249">İçeren tüm URL 'Lerin `/Identity/` sunucuya düzenli olarak yalnızca çevrimiçi istekler olarak işlenmesi gerekiyorsa, `service-worker.published.js` `onFetch` mantığı değiştirin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-249">If all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify `service-worker.published.js` `onFetch` logic.</span></span> <span data-ttu-id="97ff0-250">Şu kodu bulun:</span><span class="sxs-lookup"><span data-stu-id="97ff0-250">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="97ff0-251">Kodu aşağıdaki şekilde değiştirin:</span><span class="sxs-lookup"><span data-stu-id="97ff0-251">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
  && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="97ff0-252">Bunu yapmazsanız, ağ bağlantısından bağımsız olarak, hizmet çalışanı bu tür URL 'Ler için istekleri karşılar ve bunları kullanarak çözer `/index.html` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-252">If you don't do this, then regardless of network connectivity, the service worker intercepts requests for such URLs and resolves them using `/index.html`.</span></span>

<span data-ttu-id="97ff0-253">Onay için dış kimlik doğrulama sağlayıcıları için ek uç noktalar ekleyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-253">Add additional endpoints for external authentication providers to the check.</span></span> <span data-ttu-id="97ff0-254">Aşağıdaki örnekte, `/signin-google` Google kimlik doğrulaması için denetim 'e eklenir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-254">In the following example, `/signin-google` for Google authentication is added to the check:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
  && !event.request.url.includes('/Identity/')
  && !event.request.url.includes('/signin-google');
```

<span data-ttu-id="97ff0-255">İçerik her zaman ağdan getirilen geliştirme ortamı için herhangi bir eylem gerekmez.</span><span class="sxs-lookup"><span data-stu-id="97ff0-255">No action is required for the Development environment, where content is always fetched from the network.</span></span>

### <a name="control-asset-caching"></a><span data-ttu-id="97ff0-256">Varlık önbelleğe alma denetimi</span><span class="sxs-lookup"><span data-stu-id="97ff0-256">Control asset caching</span></span>

<span data-ttu-id="97ff0-257">Projeniz MSBuild özelliğini tanımlarsa `ServiceWorkerAssetsManifest` , Blazor derleme araçları, belirtilen ada sahip bir hizmet çalışanı varlık bildirimi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-257">If your project defines the `ServiceWorkerAssetsManifest` MSBuild property, Blazor's build tooling generates a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="97ff0-258">Varsayılan PWA şablonu, aşağıdaki özelliği içeren bir proje dosyası üretir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-258">The default PWA template produces a project file containing the following property:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="97ff0-259">Dosya `wwwroot` çıkış dizinine yerleştirilir, bu nedenle tarayıcı bu dosyayı isteyerek alabilir `/service-worker-assets.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-259">The file is placed in the `wwwroot` output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="97ff0-260">Bu dosyanın içeriğini görmek için `/bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js` bir metin düzenleyicisinde açın.</span><span class="sxs-lookup"><span data-stu-id="97ff0-260">To see the contents of this file, open `/bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js` in a text editor.</span></span> <span data-ttu-id="97ff0-261">Ancak, her bir derlemede yeniden oluşturulduğundan dosyayı düzenlemeyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-261">However, don't edit the file, as it's regenerated on each build.</span></span>

<span data-ttu-id="97ff0-262">Varsayılan olarak, bu bildirim şunları listeler:</span><span class="sxs-lookup"><span data-stu-id="97ff0-262">By default, this manifest lists:</span></span>

* <span data-ttu-id="97ff0-263">Blazor.NET derlemeleri ve .net WebAssembly çalışma zamanı dosyaları gibi, çevrimdışı çalışmak için gerekli olan herhangi bir yönetilen kaynak.</span><span class="sxs-lookup"><span data-stu-id="97ff0-263">Any Blazor-managed resources, such as .NET assemblies and the .NET WebAssembly runtime files required to function offline.</span></span>
* <span data-ttu-id="97ff0-264">`wwwroot`Dış projeler ve NuGet paketleri tarafından sağlanan statik Web varlıkları da dahil olmak üzere, uygulamanın dizinine (resimler, stil sayfaları ve JavaScript dosyaları) yayımlama için tüm kaynaklar.</span><span class="sxs-lookup"><span data-stu-id="97ff0-264">All resources for publishing to the app's `wwwroot` directory, such as images, stylesheets, and JavaScript files, including static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="97ff0-265">İçindeki içindeki mantığı düzenleyerek, bu kaynakların hangisinin hizmet çalışanı tarafından alındığını ve önbelleğe alınacağını denetleyebilirsiniz `onInstall` `service-worker.published.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-265">You can control which of these resources are fetched and cached by the service worker by editing the logic in `onInstall` in `service-worker.published.js`.</span></span> <span data-ttu-id="97ff0-266">Varsayılan olarak, hizmet çalışanı,,, ve gibi tipik Web dosya adı uzantılarına ve `.html` `.css` `.js` `.wasm` Blazor WebAssembly (,) öğesine özgü dosya türleri `.dll` `.pdb` ile eşleşen dosyaları getirir ve önbelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-266">By default, the service worker fetches and caches files matching typical web filename extensions such as `.html`, `.css`, `.js`, and `.wasm`, plus file types specific to Blazor WebAssembly (`.dll`, `.pdb`).</span></span>

<span data-ttu-id="97ff0-267">Uygulamanın dizininde bulunmayan ek kaynakları dahil etmek için, `wwwroot` `ItemGroup` Aşağıdaki örnekte gösterildiği gibi ek MSBuild girişleri tanımlayın:</span><span class="sxs-lookup"><span data-stu-id="97ff0-267">To include additional resources that aren't present in the app's `wwwroot` directory, define extra MSBuild `ItemGroup` entries, as shown in the following example:</span></span>

```xml
<ItemGroup>
  <ServiceWorkerAssetsManifestItem Include="MyDirectory\AnotherFile.json"
    RelativePath="MyDirectory\AnotherFile.json" AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="97ff0-268">`AssetUrl`Meta veriler, tarayıcının önbelleğe kaynağı getirilirken kullanması gereken temel göreli URL 'yi belirtir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-268">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="97ff0-269">Bu, diskteki özgün kaynak dosya adından bağımsız olabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-269">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="97ff0-270">Eklemek `ServiceWorkerAssetsManifestItem` , dosyanın uygulamanın dizininde yayımlanmasına neden olmaz `wwwroot` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-270">Adding a `ServiceWorkerAssetsManifestItem` doesn't cause the file to be published in the app's `wwwroot` directory.</span></span> <span data-ttu-id="97ff0-271">Yayımlama çıkışı ayrı olarak denetlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-271">The publish output must be controlled separately.</span></span> <span data-ttu-id="97ff0-272">`ServiceWorkerAssetsManifestItem`Yalnızca hizmet çalışanı varlıkları bildiriminde ek bir girdinin görünmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-272">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="97ff0-273">Anında iletme bildirimleri</span><span class="sxs-lookup"><span data-stu-id="97ff0-273">Push notifications</span></span>

<span data-ttu-id="97ff0-274">Diğer herhangi bir PWA gibi, bir Blazor WebAssembly PWA arka uç sunucusundan anında iletme bildirimleri alabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-274">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="97ff0-275">Sunucu, uygulamayı etkin bir şekilde kullanmıyor olsa bile, herhangi bir zamanda anında iletme bildirimleri gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-275">The server can send push notifications at any time, even when the user isn't actively using the app.</span></span> <span data-ttu-id="97ff0-276">Örneğin, farklı bir Kullanıcı ilgili bir eylem gerçekleştirdiğinde anında iletme bildirimleri gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-276">For example, push notifications can be sent when a different user performs a relevant action.</span></span>

<span data-ttu-id="97ff0-277">Anında iletme bildirimi gönderme mekanizması Blazor WebAssembly , herhangi bir teknolojiyi kullanan arka uç sunucu tarafından uygulandığından tamamen bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-277">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="97ff0-278">Bir ASP.NET Core sunucusundan anında iletme bildirimleri göndermek istiyorsanız, [güçlendirme, pizza Atölyesi Workshop ' de gerçekleştirilen yaklaşıma benzer bir teknik kullanmayı](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)düşünün.</span><span class="sxs-lookup"><span data-stu-id="97ff0-278">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to the approach taken in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="97ff0-279">Blazor WebAssemblyHizmet çalışanı JavaScript dosyasında uygulandığından, istemcide anında iletme bildirimi alma ve görüntüleme mekanizması da bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-279">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker JavaScript file.</span></span> <span data-ttu-id="97ff0-280">Bir örnek için bkz. [güçlendirme pizza 'da kullanılan yaklaşım](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span><span class="sxs-lookup"><span data-stu-id="97ff0-280">For an example, see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="97ff0-281">Çevrimdışı PDI uyarıları</span><span class="sxs-lookup"><span data-stu-id="97ff0-281">Caveats for offline PWAs</span></span>

<span data-ttu-id="97ff0-282">Tüm uygulamalar çevrimdışı kullanımı desteklemeyi denememelidir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-282">Not all apps should attempt to support offline use.</span></span> <span data-ttu-id="97ff0-283">Çevrimdışı destek, önemli karmaşıklık ekler, ancak her zaman gereken kullanım durumları için geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-283">Offline support adds significant complexity, while not always being relevant for the use cases required.</span></span>

<span data-ttu-id="97ff0-284">Çevrimdışı destek genellikle ilgilidir:</span><span class="sxs-lookup"><span data-stu-id="97ff0-284">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="97ff0-285">Birincil veri deposu tarayıcıya yereldir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-285">If the primary data store is local to the browser.</span></span> <span data-ttu-id="97ff0-286">Örneğin, yaklaşım, verileri [](https://en.wikipedia.org/wiki/Internet_of_things) `localStorage` veya [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API)'yi depolayan bir IoT cihazına yönelik kullanıcı arabirimine sahip bir uygulama ile ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-286">For example, the approach is relevant in an app with a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>
* <span data-ttu-id="97ff0-287">Uygulama, her kullanıcıyla ilgili arka uç API verisini getirmek ve önbelleğe almak için önemli miktarda iş gerçekleştiriyorsa, bu sayede verileri çevrimdışı olarak gezinebilirler.</span><span class="sxs-lookup"><span data-stu-id="97ff0-287">If the app performs a significant amount of work to fetch and cache the backend API data relevant to each user so that they can navigate through the data offline.</span></span> <span data-ttu-id="97ff0-288">Uygulamanın düzenlemesini desteklemesi gerekiyorsa, değişiklikleri izlemeye yönelik bir sistem, arka uca veri eşitlemesi oluşturulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-288">If the app must support editing, a system for tracking changes and synchronizing data with the backend must be built.</span></span>
* <span data-ttu-id="97ff0-289">Hedef ise, ağ koşullarından bağımsız olarak uygulamanın hemen yüklendiğini güvence altına almak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-289">If the goal is to guarantee that the app loads immediately regardless of network conditions.</span></span> <span data-ttu-id="97ff0-290">İsteklerin ilerlemesini göstermek için arka uç API 'SI isteklerinde uygun bir kullanıcı deneyimi uygulayın ve ağ kullanılamamasından kaynaklanan istekler başarısız olduğunda düzgün bir şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-290">Implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when requests fail due to network unavailability.</span></span>

<span data-ttu-id="97ff0-291">Ayrıca, çevrimdışı yetenekli PWAs bir dizi ek karmaşıklıklarla uğraşmalıdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-291">Additionally, offline-capable PWAs must deal with a range of additional complications.</span></span> <span data-ttu-id="97ff0-292">Geliştiriciler, aşağıdaki bölümlerdeki uyarıları dikkatle dikkatlice bilmelidir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-292">Developers should carefully familiarize themselves with the caveats in the following sections.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="97ff0-293">Yalnızca yayımlandığında çevrimdışı destek</span><span class="sxs-lookup"><span data-stu-id="97ff0-293">Offline support only when published</span></span>

<span data-ttu-id="97ff0-294">Geliştirme sırasında, genellikle her bir değişikliğin bir arka plan güncelleştirme işlemine geçmeden hemen tarayıcıda yansıtıldığını görmek istersiniz.</span><span class="sxs-lookup"><span data-stu-id="97ff0-294">During development you typically want to see each change reflected immediately in the browser without going through a background update process.</span></span> <span data-ttu-id="97ff0-295">Bu nedenle, Blazor PWA şablonu yalnızca yayımlandığında çevrimdışı desteğe izin vermez.</span><span class="sxs-lookup"><span data-stu-id="97ff0-295">Therefore, Blazor's PWA template enables offline support only when published.</span></span>

<span data-ttu-id="97ff0-296">Çevrimdışı özellikli bir uygulama oluştururken uygulamayı geliştirme ortamında test etmek yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-296">When building an offline-capable app, it's not enough to test the app in the Development environment.</span></span> <span data-ttu-id="97ff0-297">Farklı ağ koşullarına nasıl yanıt verdiğini anlamak için uygulamayı yayımlanmış durumunda test etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-297">You must test the app in its published state to understand how it responds to different network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="97ff0-298">Uygulamadan sonra Kullanıcı gezindikten sonra tamamlamayı Güncelleştir</span><span class="sxs-lookup"><span data-stu-id="97ff0-298">Update completion after user navigation away from app</span></span>

<span data-ttu-id="97ff0-299">Kullanıcılar uygulamadan tüm sekmelerde gezinene kadar güncelleştirmeler tamamlanmaz.</span><span class="sxs-lookup"><span data-stu-id="97ff0-299">Updates don't complete until the user has navigated away from the app in all tabs.</span></span> <span data-ttu-id="97ff0-300">[Arka plan güncelleştirmeleri](#background-updates) bölümünde açıklandığı gibi, uygulamaya bir güncelleştirme dağıttıktan sonra, tarayıcı güncelleştirme işlemini başlatmak için güncelleştirilmiş hizmet çalışanı dosyalarını getirir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-300">As explained in the [Background updates](#background-updates) section, after you deploy an update to the app, the browser fetches the updated service worker files to begin the update process.</span></span>

<span data-ttu-id="97ff0-301">Birçok geliştirici, bu güncelleştirme tamamlandığında bile Kullanıcı tüm sekmelerde gezinene kadar **etkili olmaz.**</span><span class="sxs-lookup"><span data-stu-id="97ff0-301">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="97ff0-302">Uygulamayı görüntüleyen tek sekme olsa bile, uygulamayı görüntüleyen sekmenin yenilenmesi yeterli **değildir** .</span><span class="sxs-lookup"><span data-stu-id="97ff0-302">It is **not** sufficient to refresh the tab displaying the app, even if it's the only tab displaying the app.</span></span> <span data-ttu-id="97ff0-303">Uygulamanız tamamen kapanana kadar, yeni hizmet çalışanı durumu *Etkinleştirme bekleniyor* durumunda kalır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-303">Until your app is completely closed, the new service worker remains in the *waiting to activate* status.</span></span> <span data-ttu-id="97ff0-304">**Bu öğesine özgü değildir Blazor , ancak standart bir Web platformu davranışı olur.**</span><span class="sxs-lookup"><span data-stu-id="97ff0-304">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="97ff0-305">Bu, yaygın olarak çalışan geliştiricilerin hizmet çalışanlarına veya Çevrimdışı önbelleğe alınmış kaynaklara yönelik güncelleştirmeleri test kurmaya çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="97ff0-305">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="97ff0-306">Tarayıcının geliştirici araçlarını iade ederseniz aşağıdakine benzer bir şey görebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="97ff0-306">If you check in the browser's developer tools, you may see something like the following:</span></span>

![Google Chrome ' uygulama ' sekmesi, uygulamanın hizmet çalışanının ' etkinleştirilmesi bekleniyor ' olduğunu gösterir.](progressive-web-app/_static/image7.png)

<span data-ttu-id="97ff0-308">Uygulamanızı görüntüleyen "istemciler" ("istemciler") listesi boş olmadığı sürece, çalışan beklemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="97ff0-308">For as long as the list of "clients," which are tabs or windows displaying your app, is nonempty, the worker continues waiting.</span></span> <span data-ttu-id="97ff0-309">Hizmet çalışanlarının bunu yapması neden olur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-309">The reason service workers do this is to guarantee consistency.</span></span> <span data-ttu-id="97ff0-310">Tutarlılık, tüm kaynakların aynı atomik önbellekten getirileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-310">Consistency means that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="97ff0-311">Değişiklikleri test ederken, yukarıdaki ekran görüntüsünde gösterildiği gibi "Skipbeklediği" bağlantısına tıklamayı kullanışlı bulabilirsiniz, sonra sayfayı yeniden yükleyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-311">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the preceding screenshot, then reload the page.</span></span> <span data-ttu-id="97ff0-312">["Bekleme" aşamasını atlayıp güncelleştirme üzerinde hemen etkinleştirmek](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)üzere hizmet çalışanınızı kodlayarak, tüm kullanıcılar için bunu otomatikleştirin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-312">You can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="97ff0-313">Bekleme aşamasını atlarsanız, kaynakların her zaman aynı önbellek örneğinden düzenli olarak getirilme garantisi vermiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="97ff0-313">If you skip the waiting phase, you're giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="97ff0-314">Kullanıcılar uygulamanın geçmiş bir sürümünü çalıştırabilir</span><span class="sxs-lookup"><span data-stu-id="97ff0-314">Users may run any historical version of the app</span></span>

<span data-ttu-id="97ff0-315">Web geliştiricileri habitually, kullanıcıların geleneksel Web Dağıtım modelinde bu yana, Web uygulamasının en son dağıtılan sürümünü çalıştırmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="97ff0-315">Web developers habitually expect that users only run the latest deployed version of their web app, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="97ff0-316">Ancak, çevrimdışı bir ilk PWA, kullanıcıların en son sürümü çalıştırması gereken yerel bir mobil uygulamaya daha fazla oturum sağlar.</span><span class="sxs-lookup"><span data-stu-id="97ff0-316">However, an offline-first PWA is more akin to a native mobile app, where users aren't necessarily running the latest version.</span></span>

<span data-ttu-id="97ff0-317">[Arka plan güncelleştirmeleri](#background-updates) bölümünde açıklandığı gibi, uygulamanıza bir güncelleştirme dağıttıktan sonra, **mevcut olan her Kullanıcı en az bir daha ziyaret için daha önceki bir sürümü kullanmaya devam eder** , çünkü güncelleştirme arka planda gerçekleştiğinden ve Kullanıcı daha sonra uzaklaşana kadar etkinleştirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="97ff0-317">As explained in the [Background updates](#background-updates) section, after you deploy an update to your app, **each existing user continues to use a previous version for at least one further visit** because the update occurs in the background and isn't activated until the user thereafter navigates away.</span></span> <span data-ttu-id="97ff0-318">Ayrıca, kullanılmakta olan önceki sürüm, dağıttığınız bir önceki sürüm değildir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-318">Plus, the previous version being used isn't necessarily the previous one you deployed.</span></span> <span data-ttu-id="97ff0-319">Önceki sürüm, kullanıcının bir güncelleştirmeyi en son ne zaman tamamladığını bağlı *olarak geçmiş sürüm* olabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-319">The previous version can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="97ff0-320">Uygulamanızın ön uç ve arka uç bölümleri API istekleri için şema hakkında anlaşma gerektiriyorsa bu bir sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-320">This can be an issue if the frontend and backend parts of your app require agreement about the schema for API requests.</span></span> <span data-ttu-id="97ff0-321">Tüm kullanıcıların yükseltildiğinden emin olana kadar, geriye dönük olarak uyumsuz API şeması değişikliklerini dağıtmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-321">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded.</span></span> <span data-ttu-id="97ff0-322">Alternatif olarak, kullanıcıların uygulamanın uyumsuz eski sürümlerini kullanmalarını engelleyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-322">Alternatively, block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="97ff0-323">Bu senaryo gereksinimi, yerel mobil uygulamalar için aynıdır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-323">This scenario requirement is the same as for native mobile apps.</span></span> <span data-ttu-id="97ff0-324">Sunucu API 'Lerinde bir son değişiklik dağıtırsanız, istemci uygulaması henüz güncelleştirilmemiş kullanıcılar için bozulur.</span><span class="sxs-lookup"><span data-stu-id="97ff0-324">If you deploy a breaking change in server APIs, the client app is broken for users who haven't yet updated.</span></span>

<span data-ttu-id="97ff0-325">Mümkünse, arka uç API 'lerinize son değişiklikleri dağıtmayın.</span><span class="sxs-lookup"><span data-stu-id="97ff0-325">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="97ff0-326">Bunu yapmanız gerekiyorsa, uygulamanın güncel olup olmadığını ve kullanım dışı olduğunu anlamak için [ServiceWorkerRegistration gibi standart hizmet çalışanı API 'lerini](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="97ff0-326">If you must do so, consider using [standard Service Worker APIs such as ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the app is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="97ff0-327">Sunucu tarafından işlenmiş sayfalarla girişim</span><span class="sxs-lookup"><span data-stu-id="97ff0-327">Interference with server-rendered pages</span></span>

<span data-ttu-id="97ff0-328">[Sunucu tarafından işlenen sayfalar](#support-server-rendered-pages) bölümünde açıklandığı gibi, hizmet çalışanının `/index.html` Tüm gezinti istekleri için içerik döndürme davranışını atlamak istiyorsanız, hizmet çalışanınızdaki mantığı düzenleyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-328">As described in the [Support server-rendered pages](#support-server-rendered-pages) section, if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="97ff0-329">Tüm hizmet çalışanı varlık bildirimi içerikleri varsayılan olarak önbelleğe alınır</span><span class="sxs-lookup"><span data-stu-id="97ff0-329">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="97ff0-330">[Denetim varlık önbelleğe alma](#control-asset-caching) bölümünde açıklandığı gibi, dosya `service-worker-assets.js` derleme sırasında oluşturulur ve hizmet çalışanının getirmesi ve önbelleğe alınması gereken tüm varlıkları listeler.</span><span class="sxs-lookup"><span data-stu-id="97ff0-330">As described in the [Control asset caching](#control-asset-caching) section, the file `service-worker-assets.js` is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="97ff0-331">Bu liste `wwwroot` , dış paketler ve projeler tarafından sağlanan içerikler dahil olmak üzere, varsayılan olarak öğesine yayılan her şeyi içerdiğinden, orada çok fazla içerik yerleştirmemeye dikkat etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-331">Since this list by default includes everything emitted to `wwwroot`, including content supplied by external packages and projects, you must be careful not to put too much content there.</span></span> <span data-ttu-id="97ff0-332">`wwwroot`Dizinde milyonlarca görüntü varsa, hizmet çalışanı, yoğun bant genişliği ve büyük olasılıkla başarıyla tamamlanmamaları tüketen, tümünü alıp önbelleğe almaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-332">If the `wwwroot` directory contains millions of images, the service worker tries to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="97ff0-333">İçindeki işlev düzenlenerek bildirim içeriğinin hangi alt kümesinin getirilmeli ve önbelleğe alınacağını denetlemek için rastgele mantık uygulayın `onInstall` `service-worker.published.js` .</span><span class="sxs-lookup"><span data-stu-id="97ff0-333">Implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in `service-worker.published.js`.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="97ff0-334">Kimlik doğrulamasıyla etkileşim</span><span class="sxs-lookup"><span data-stu-id="97ff0-334">Interaction with authentication</span></span>

<span data-ttu-id="97ff0-335">PWA şablonu, kimlik doğrulamasıyla birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-335">The PWA template can be used in conjunction with authentication.</span></span> <span data-ttu-id="97ff0-336">Çevrimdışı özellikli bir PWA, kullanıcının ilk ağ bağlantısı olduğunda kimlik doğrulamasını da destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-336">An offline-capable PWA can also support authentication when the user has initial network connectivity.</span></span>

<span data-ttu-id="97ff0-337">Bir kullanıcının ağ bağlantısı yoksa, kimlik doğrulaması yapamaz veya erişim belirteçleri elde etmez.</span><span class="sxs-lookup"><span data-stu-id="97ff0-337">When a user doesn't have network connectivity, they can't authenticate or obtain access tokens.</span></span> <span data-ttu-id="97ff0-338">Varsayılan olarak, ağ erişimi olmadan oturum açma sayfasını ziyaret etme girişimi, "ağ hatası" iletisiyle sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="97ff0-338">By default, attempting to visit the login page without network access results in a "network error" message.</span></span> <span data-ttu-id="97ff0-339">Kullanıcının kimliğini doğrulamaya veya erişim belirteçleri almaya çalışmadan, kullanıcının çevrimdışıyken yararlı görevler gerçekleştirmesini sağlayan bir UI akışı tasarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-339">You must design a UI flow that allows the user perform useful tasks while offline without attempting to authenticate the user or obtain access tokens.</span></span> <span data-ttu-id="97ff0-340">Alternatif olarak, ağ kullanılamadığında, uygulamayı düzgün bir şekilde başarısız olacak şekilde tasarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="97ff0-340">Alternatively, you can design the app to gracefully fail when the network isn't available.</span></span> <span data-ttu-id="97ff0-341">Uygulama bu senaryoları işleyecek şekilde tasarlanamaz, çevrimdışı desteği etkinleştirmek istemeyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="97ff0-341">If the app can't be designed to handle these scenarios, you might not want to enable offline support.</span></span>

<span data-ttu-id="97ff0-342">Çevrimiçi ve çevrimdışı kullanım için tasarlanan bir uygulama yeniden çevrimiçi olduğunda:</span><span class="sxs-lookup"><span data-stu-id="97ff0-342">When an app that's designed for online and offline use is online again:</span></span>

* <span data-ttu-id="97ff0-343">Uygulamanın yeni bir erişim belirteci sağlaması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-343">The app might need to provision a new access token.</span></span>
* <span data-ttu-id="97ff0-344">Uygulamanın, çevrimdışıyken gerçekleştirilen kullanıcı hesabına işlem uygulayabilmesi için farklı bir kullanıcının hizmette oturum açmış olup olmadığını algılaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-344">The app must detect if a different user is signed into the service so that it can apply operations to the user's account that were made while they were offline.</span></span>

<span data-ttu-id="97ff0-345">Kimlik doğrulamasıyla etkileşime sahip bir çevrimdışı PWA uygulaması oluşturmak için:</span><span class="sxs-lookup"><span data-stu-id="97ff0-345">To create an offline PWA app that interacts with authentication:</span></span>

* <span data-ttu-id="97ff0-346">' Nı, <xref:Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccountClaimsPrincipalFactory%601> son oturum açan kullanıcıyı depolayan ve uygulama çevrimdışıyken depolanan kullanıcıyı kullanan bir fabrika ile değiştirin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-346">Replace the <xref:Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccountClaimsPrincipalFactory%601> with a factory that stores the last signed-in user and uses the stored user when the app is offline.</span></span>
* <span data-ttu-id="97ff0-347">Uygulama çevrimdışıyken sıraya alma işlemleri yapın ve uygulama çevrimiçi olarak geri döndüğünde bunları uygulayın.</span><span class="sxs-lookup"><span data-stu-id="97ff0-347">Queue operations while the app is offline and apply them when the app returns online.</span></span>
* <span data-ttu-id="97ff0-348">Oturumu kapatma sırasında, depolanan kullanıcıyı temizleyin.</span><span class="sxs-lookup"><span data-stu-id="97ff0-348">During sign out, clear the stored user.</span></span>

<span data-ttu-id="97ff0-349">[`CarChecker`](https://github.com/SteveSandersonMS/CarChecker)Örnek uygulama önceki yaklaşımları gösterir.</span><span class="sxs-lookup"><span data-stu-id="97ff0-349">The [`CarChecker`](https://github.com/SteveSandersonMS/CarChecker) sample app demonstrates the preceding approaches.</span></span> <span data-ttu-id="97ff0-350">Uygulamanın aşağıdaki bölümlerine bakın:</span><span class="sxs-lookup"><span data-stu-id="97ff0-350">See the following parts of the app:</span></span>

* <span data-ttu-id="97ff0-351">`OfflineAccountClaimsPrincipalFactory` (`Client/Data/OfflineAccountClaimsPrincipalFactory.cs`)</span><span class="sxs-lookup"><span data-stu-id="97ff0-351">`OfflineAccountClaimsPrincipalFactory` (`Client/Data/OfflineAccountClaimsPrincipalFactory.cs`)</span></span>
* <span data-ttu-id="97ff0-352">`LocalVehiclesStore` (`Client/Data/LocalVehiclesStore.cs`)</span><span class="sxs-lookup"><span data-stu-id="97ff0-352">`LocalVehiclesStore` (`Client/Data/LocalVehiclesStore.cs`)</span></span>
* <span data-ttu-id="97ff0-353">`LoginStatus` bileşen ( `Client/Shared/LoginStatus.razor` )</span><span class="sxs-lookup"><span data-stu-id="97ff0-353">`LoginStatus` component (`Client/Shared/LoginStatus.razor`)</span></span>

## <a name="additional-resources"></a><span data-ttu-id="97ff0-354">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="97ff0-354">Additional resources</span></span>

* [<span data-ttu-id="97ff0-355">Bütünlük PowerShell betiği sorunlarını giderme</span><span class="sxs-lookup"><span data-stu-id="97ff0-355">Troubleshoot integrity PowerShell script</span></span>](xref:blazor/host-and-deploy/webassembly#troubleshoot-integrity-powershell-script)
* [<span data-ttu-id="97ff0-356">SignalR kimlik doğrulaması için çıkış noktaları arası anlaşma</span><span class="sxs-lookup"><span data-stu-id="97ff0-356">SignalR cross-origin negotiation for authentication</span></span>](xref:blazor/fundamentals/additional-scenarios#signalr-cross-origin-negotiation-for-authentication)
